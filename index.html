<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Chess Squad ‚Äì Motivation & Belohnungen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);
      color: #e5e7eb;
    }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1.25rem 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    main {
      width: 100%;
      max-width: 1100px;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(2rem, 3vw, 2.5rem);
      text-align: center;
    }

    .subtitle {
      color: #9ca3af;
      font-size: 0.9rem;
      text-align: center;
      margin-top: 0.5rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      width: 100%;
    }

    .card {
      background: radial-gradient(circle at top, #111827, #020617);
      border-radius: 1rem;
      padding: 1.2rem 1.4rem 1.3rem;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 45px rgba(0,0,0,0.6);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 0.6rem;
    }

    .card-title-block {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .avatar {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 2px solid #22c55e;
      object-fit: cover;
      background: #020617;
      flex-shrink: 0;
    }

    .username {
      font-weight: 600;
      font-size: 1.05rem;
    }

    .status-badge {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .status-active {
      background: #065f46;
      color: #bbf7d0;
    }

    .status-chill {
      background: #7f1d1d;
      color: #fecaca;
    }

    .section-title {
      margin-top: 0.7rem;
      font-size: 0.82rem;
      font-weight: 600;
      color: #d1d5db;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .modes {
      margin-top: 0.3rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.78rem;
    }

    .mode-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.6rem;
      background: rgba(15,23,42,0.7);
    }

    .mode-left {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }

    .mode-label {
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .mode-meta {
      color: #9ca3af;
      font-size: 0.72rem;
    }

    .mode-right {
      text-align: right;
      font-size: 0.76rem;
    }

    .rating {
      font-weight: 600;
      color: #facc15;
    }

    .gap-good {
      color: #22c55e;
    }
    .gap-mid {
      color: #eab308;
    }
    .gap-bad {
      color: #f97316;
    }

    .badge-row {
      margin-top: 0.4rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      font-size: 0.72rem;
    }

    .badge {
      padding: 0.18rem 0.55rem;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      white-space: nowrap;
      cursor: default;
    }

    .badge.gold {
      border-color: #fbbf24;
      color: #facc15;
    }

    .badge.silver {
      border-color: #9ca3af;
      color: #e5e7eb;
    }

    .badge.bronze {
      border-color: #f97316;
      color: #fed7aa;
    }

    .badge.fail {
      border-color: #ef4444;
      color: #fecaca;
    }

    .focus {
      margin-top: 0.6rem;
      font-size: 0.8rem;
      line-height: 1.4;
      padding: 0.45rem 0.55rem;
      border-radius: 0.6rem;
      background: rgba(15,23,42,0.85);
      border: 1px dashed #1f2937;
      color: #e5e7eb;
    }

    .focus strong {
      color: #a5b4fc;
    }

    .reward-row {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      row-gap: 0.15rem;
      column-gap: 0.5rem;
    }

    .reward-label {
      color: #9ca3af;
    }

    .reward-value {
      text-align: right;
      font-weight: 600;
    }

    .reward-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.15rem 0.55rem;
      border-radius: 999px;
      font-size: 0.7rem;
      margin-top: 0.35rem;
    }

    .chip-open {
      background: rgba(234,179,8,0.15);
      border: 1px solid #eab308;
      color: #fde68a;
    }

    .chip-requested {
      background: rgba(59,130,246,0.15);
      border: 1px solid #3b82f6;
      color: #bfdbfe;
    }

    .chip-paid {
      background: rgba(34,197,94,0.15);
      border: 1px solid #22c55e;
      color: #bbf7d0;
    }

    .btn {
      margin-top: 0.5rem;
      padding: 0.35rem 0.8rem;
      border-radius: 999px;
      border: 1px solid #22c55e;
      background: #022c22;
      color: #bbf7d0;
      font-size: 0.75rem;
      cursor: pointer;
    }
    .btn:hover {
      filter: brightness(1.1);
    }

    .btn-danger {
      border-color: #ef4444;
      background: #450a0a;
      color: #fecaca;
      margin-left: 0.3rem;
    }

    .weekly-goals {
      margin-top: 0.4rem;
      font-size: 0.78rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .weekly-goal-row {
      display: flex;
      justify-content: space-between;
      gap: 0.4rem;
      padding: 0.2rem 0.3rem;
      border-radius: 0.5rem;
      background: rgba(15,23,42,0.6);
    }

    .weekly-goal-label {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }

    .weekly-goal-name {
      font-weight: 500;
    }

    .weekly-goal-meta {
      font-size: 0.72rem;
      color: #9ca3af;
    }

    .weekly-goal-status {
      font-size: 0.75rem;
      text-align: right;
    }

    .status-ok {
      color: #bbf7d0;
    }

    .status-paid {
      color: #93c5fd;
    }

    .status-missing {
      color: #facc15;
    }

    .squad-card {
      background: #020617;
      border-radius: 0.9rem;
      border: 1px solid #1f2937;
      padding: 1rem 1.2rem;
    }

    .squad-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .squad-list {
      font-size: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    footer {
      font-size: 0.75rem;
      color: #6b7280;
      text-align: center;
      margin-top: 1.5rem;
    }

    a {
      color: #60a5fa;
    }
  </style>
</head>
<body>
  <main>
    <header style="text-align:center;">
      <h1>‚ôüÔ∏è Chess Squad ‚Äì Motivation & Belohnungen</h1>
      <p class="subtitle" id="subtitle">
        Lade Live-Daten von Chess.com‚Ä¶
      </p>
    </header>

    <section class="grid" id="cards"></section>
    <section id="squad"></section>

    <footer>
      Datenquelle: <a href="https://www.chess.com/news/view/published-data-api" target="_blank" rel="noreferrer">Chess.com Published Data API</a> ¬∑ Backend: Firebase Firestore
    </footer>
  </main>

  <script type="module">
    // === Firebase Setup ===
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js';
    import {
      getFirestore,
      doc,
      getDoc,
      setDoc,
      updateDoc,
      serverTimestamp
    } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js';

    // Deine Firebase Config
    const firebaseConfig = {
      apiKey: "AIzaSyBtEkLjoW0pEqxOodau5dAArMkkf1hgjnc",
      authDomain: "chess-rewards.firebaseapp.com",
      projectId: "chess-rewards",
      storageBucket: "chess-rewards.firebasestorage.app",
      messagingSenderId: "118996095284",
      appId: "1:118996095284:web:0a80d27fe93668563cd561"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // === Konfiguration ===
    const PLAYERS = ["ERR_Daemon", "M41K", "Kathi_2905"];
    const CHEF_USERNAME = "M41K"; // du, bekommst keine Rewards angezeigt

    const MODES = [
      { key: "chess_rapid", label: "Rapid",  icon: "‚è±Ô∏è" },
      { key: "chess_blitz", label: "Blitz",  icon: "‚ö°" },
      { key: "chess_bullet",label: "Bullet", icon: "üí£" },
      { key: "chess_daily", label: "Daily",  icon: "üì¨" },
    ];

    const RAPID_MILESTONES = [
      { rating: 500,  reward:  50 },
      { rating: 1000, reward: 100 },
      { rating: 1500, reward: 150 },
      { rating: 2000, reward: 200 }
    ];

    const REWARD_COLLECTION = "rewardProgress";

    // Weekly Activity
    const WEEKLY_COLLECTION = "weeklyActivity";
    const WEEKLY_CAP = 10;

    const WEEKLY_GOALS = [
      {
        id: "rapid10",
        label: "10 Rapid-Partien in dieser Woche",
        amount: 3,
        description: "Mindestens 10 Rapid-Games (time_class = rapid) zwischen Montag und Sonntag.",
      },
      {
        id: "games20",
        label: "20 Partien insgesamt",
        amount: 3,
        description: "Mindestens 20 Games (egal welches Format) in dieser Woche.",
      },
      {
        id: "days5",
        label: "An 5 Tagen gespielt",
        amount: 3,
        description: "An mindestens 5 verschiedenen Tagen in dieser Woche mindestens eine Partie.",
      },
      {
        id: "days7",
        label: "An 7 Tagen gespielt",
        amount: 5,
        description: "Jeden Tag dieser Woche mindestens eine Partie.",
      },
      {
        id: "noTimeouts",
        label: "Kein Timeout",
        amount: 2,
        description: "Du hast diese Woche keine Partie durch Timeout verloren.",
      }
    ];

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error("HTTP " + res.status + " for " + url);
      return res.json();
    }

    // === Chess.com Stats laden ===
    async function loadChessStats(username) {
      const uname = username.toLowerCase();
      const [profile, stats] = await Promise.allSettled([
        fetchJson(`https://api.chess.com/pub/player/${uname}`),
        fetchJson(`https://api.chess.com/pub/player/${uname}/stats`)
      ]);

      const profileData = profile.status === "fulfilled" ? profile.value : {};
      const statsData   = stats.status === "fulfilled"   ? stats.value   : {};

      const modes = MODES.map(m => extractMode(statsData, m.key, m.label, m.icon))
        .filter(Boolean);

      const tactics = extractTactics(statsData);

      const totalGames = modes.reduce((sum, m) => sum + m.games, 0);
      const active = totalGames > 0;

      const tacticsRating = tactics?.current ?? null;
      const rapidMode = modes.find(m => m.key === "chess_rapid");
      const rapidRating = rapidMode?.current ?? null;

      return {
        username,
        avatar: profileData.avatar || null,
        url: profileData.url || null,
        modes,
        tactics,
        totalGames,
        active,
        tacticsRating,
        rapidRating
      };
    }

    function extractMode(stats, key, label, icon) {
      const s = stats[key];
      if (!s || !s.last || !s.record) return null;

      const current = s.last.rating ?? null;
      const best    = s.best && s.best.rating != null ? s.best.rating : null;
      const rec     = s.record || {};
      const wins  = rec.win   || 0;
      const loss  = rec.loss  || 0;
      const draw  = rec.draw  || 0;
      const games = wins + loss + draw;
      const winrate = games ? Math.round((wins / games) * 100) : null;
      const gap = (best != null && current != null) ? best - current : null;

      return {
        key,
        label,
        icon,
        current,
        best,
        wins,
        loss,
        draw,
        games,
        winrate,
        gap
      };
    }

    function extractTactics(stats) {
      const t = stats.tactics;
      if (!t) return null;
      const last    = t.last || {};
      const highest = t.highest || {};
      const lowest  = t.lowest || {};
      const current = last.rating ?? highest.rating ?? null;
      return {
        current,
        highest: highest.rating ?? null,
        lowest: lowest.rating ?? null
      };
    }

    // === Firestore Reward-Dokument (Lebenszeit) ===
    async function loadRewardDoc(username, tacticsRating, rapidRating) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      const snap = await getDoc(ref);

      if (!snap.exists()) {
        const baselineTactics = tacticsRating ?? 0;
        const baselineRapid   = rapidRating ?? 0;
        const initData = {
          baselineTactics,
          baselineRapid,
          tacticsStepsClaimed: 0,
          rapidStepsClaimed: 0,
          rapidMilestonesClaimed: [],
          pendingClaim: null,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        };
        await setDoc(ref, initData);
        return initData;
      }

      return snap.data();
    }

    // === Lebenszeit-Rewards berechnen ===
    function computeRewardState(username, tacticsRating, rapidRating, rewardDoc) {
      const isChef = username === CHEF_USERNAME;

      const baselineT = rewardDoc.baselineTactics ?? 0;
      const baselineR = rewardDoc.baselineRapid   ?? 0;

      const tNow = tacticsRating ?? 0;
      const rNow = rapidRating   ?? 0;

      // Taktik: 10 ‚Ç¨ pro +100 Elo √ºber Baseline
      const deltaT = Math.max(0, tNow - baselineT);
      const tacticsStepsTotal = Math.floor(deltaT / 100);
      const tacticsRewardRaw  = tacticsStepsTotal * 10;

      const tacticsStepsClaimed = rewardDoc.tacticsStepsClaimed ?? 0;
      const tacticsStepsPaid    = Math.min(tacticsStepsClaimed, tacticsStepsTotal);
      const tacticsStepsNew     = Math.max(0, tacticsStepsTotal - tacticsStepsPaid);
      const tacticsPaid         = tacticsStepsPaid * 10;
      const tacticsUnpaid       = tacticsStepsNew  * 10;

      const nextTacticsTarget = baselineT + (tacticsStepsTotal + 1) * 100;
      const tacticsToNext     = Math.max(0, nextTacticsTarget - tNow);

      // Rapid: 10 ‚Ç¨ pro +100 Elo √ºber Baseline + Meilensteine
      const deltaR = Math.max(0, rNow - baselineR);
      const rapidStepsTotal = Math.floor(deltaR / 100);
      const rapidStepsRewardRaw = rapidStepsTotal * 10;

      const rapidStepsClaimed = rewardDoc.rapidStepsClaimed ?? 0;
      const rapidStepsPaid    = Math.min(rapidStepsClaimed, rapidStepsTotal);
      const rapidStepsNew     = Math.max(0, rapidStepsTotal - rapidStepsPaid);
      const rapidStepsPaidEuro   = rapidStepsPaid * 10;
      const rapidStepsUnpaidEuro = rapidStepsNew * 10;

      const claimedMilestones = rewardDoc.rapidMilestonesClaimed ?? [];
      const reachedMilestones = RAPID_MILESTONES.filter(m =>
        m.rating > baselineR && m.rating <= rNow
      );
      const newMilestones = reachedMilestones.filter(m => !claimedMilestones.includes(m.rating));
      const milestoneRewardRaw = reachedMilestones.reduce((sum, m) => sum + m.reward, 0);
      const milestonePaid = reachedMilestones
        .filter(m => claimedMilestones.includes(m.rating))
        .reduce((sum, m) => sum + m.reward, 0);
      const milestoneUnpaid = milestoneRewardRaw - milestonePaid;

      const rapidRewardRaw = rapidStepsRewardRaw + milestoneRewardRaw;
      const rapidPaid      = rapidStepsPaidEuro + milestonePaid;
      const rapidUnpaid    = rapidStepsUnpaidEuro + milestoneUnpaid;

      const totalRaw    = tacticsRewardRaw + rapidRewardRaw;
      const totalPaid   = tacticsPaid + rapidPaid;
      const totalUnpaid = totalRaw - totalPaid;

      const pending = rewardDoc.pendingClaim || null;

      const claimable = {
        tacticsStepsToClaim: tacticsStepsNew,
        rapidStepsToClaim: rapidStepsNew,
        rapidMilestonesToClaim: newMilestones.map(m => m.rating),
        amount: totalUnpaid
      };

      return {
        isChef,
        baselineT,
        baselineR,
        tactics: {
          now: tNow,
          delta: deltaT,
          stepsTotal: tacticsStepsTotal,
          rewardRaw: tacticsRewardRaw,
          paid: tacticsPaid,
          unpaid: tacticsUnpaid,
          toNext: tacticsToNext
        },
        rapid: {
          now: rNow,
          delta: deltaR,
          stepsTotal: rapidStepsTotal,
          stepsRewardRaw: rapidStepsRewardRaw,
          stepsPaidEuro: rapidStepsPaidEuro,
          stepsUnpaidEuro: rapidStepsUnpaidEuro,
          reachedMilestones,
          claimedMilestones,
          newMilestones,
          milestoneRewardRaw,
          milestonePaid,
          milestoneUnpaid,
          rewardRaw: rapidRewardRaw,
          paid: rapidPaid,
          unpaid: rapidUnpaid
        },
        total: {
          raw: totalRaw,
          paid: totalPaid,
          unpaid: totalUnpaid
        },
        claimable,
        pending
      };
    }

    async function createLifetimeClaim(username, rewardState) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);

      const { claimable } = rewardState;
      if (claimable.amount <= 0) return;

      const pendingClaim = {
        status: "requested",
        amount: claimable.amount,
        tacticsStepsToClaim: claimable.tacticsStepsToClaim,
        rapidStepsToClaim: claimable.rapidStepsToClaim,
        rapidMilestonesToClaim: claimable.rapidMilestonesToClaim,
        createdAt: serverTimestamp()
      };

      await updateDoc(ref, {
        pendingClaim,
        updatedAt: serverTimestamp()
      });
    }

    async function markLifetimeClaimPaid(username, rewardState) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      const pending = rewardState.pending;
      if (!pending || pending.status !== "requested") return;

      const snap = await getDoc(ref);
      if (!snap.exists()) return;
      const data = snap.data();

      const currentTacticsStepsClaimed = data.tacticsStepsClaimed ?? 0;
      const currentRapidStepsClaimed   = data.rapidStepsClaimed ?? 0;
      const currentRapidMilestonesClaimed = data.rapidMilestonesClaimed ?? [];

      const newTacticsStepsClaimed =
        currentTacticsStepsClaimed + (pending.tacticsStepsToClaim || 0);
      const newRapidStepsClaimed =
        currentRapidStepsClaimed + (pending.rapidStepsToClaim || 0);

      const newMilestonesClaimed = Array.from(
        new Set([
          ...currentRapidMilestonesClaimed,
          ...(pending.rapidMilestonesToClaim || [])
        ])
      );

      await updateDoc(ref, {
        tacticsStepsClaimed: newTacticsStepsClaimed,
        rapidStepsClaimed: newRapidStepsClaimed,
        rapidMilestonesClaimed: newMilestonesClaimed,
        pendingClaim: {
          ...pending,
          status: "paid",
          resolvedAt: serverTimestamp()
        },
        updatedAt: serverTimestamp()
      });
    }

    async function resetLifetimeClaim(username) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      await updateDoc(ref, {
        pendingClaim: null,
        updatedAt: serverTimestamp()
      });
    }

    // === Weekly Activity: Zeitbereich der aktuellen Woche (Mo‚ÄìSo) ===
    function getCurrentWeekRange() {
      const now = new Date();
      const day = now.getDay(); // 0=So,1=Mo,...6=Sa
      const diffToMonday = (day === 0 ? -6 : 1 - day); // Montag als Start
      const monday = new Date(now);
      monday.setHours(0,0,0,0);
      monday.setDate(monday.getDate() + diffToMonday);

      const sunday = new Date(monday);
      sunday.setDate(sunday.getDate() + 6);
      sunday.setHours(23,59,59,999);

      const weekStartMs = monday.getTime();
      const weekEndMs = sunday.getTime();

      // Woche als Schl√ºssel: YYYY-Www
      const year = monday.getFullYear();
      const weekNumber = getISOWeekNumber(monday);
      const weekKey = `${year}-W${String(weekNumber).padStart(2, "0")}`;

      return { weekStartMs, weekEndMs, weekKey };
    }

    function getISOWeekNumber(date) {
      const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = tmp.getUTCDay() || 7;
      tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 1));
      const weekNo = Math.ceil(((tmp - yearStart) / 86400000 + 1) / 7);
      return weekNo;
    }

    // === Weekly Activity: Chess.com Games dieser Woche laden ===
    async function loadWeeklyStats(username) {
      const uname = username.toLowerCase();
      const { weekStartMs, weekEndMs } = getCurrentWeekRange();

      const startDate = new Date(weekStartMs);
      const endDate = new Date(weekEndMs);

      const months = getMonthsBetween(startDate, endDate);
      let totalGamesWeek = 0;
      let rapidGamesWeek = 0;
      let timeoutsWeek = 0;
      const activeDayIndexes = new Set();

      for (const { year, month } of months) {
        const monthStr = String(month).padStart(2, "0");
        try {
          const data = await fetchJson(`https://api.chess.com/pub/player/${uname}/games/${year}/${monthStr}`);
          const games = data.games || [];
          for (const g of games) {
            if (!g.end_time) continue;
            const endMs = g.end_time * 1000;
            if (endMs < weekStartMs || endMs > weekEndMs) continue;

            totalGamesWeek++;

            if (g.time_class === "rapid") {
              rapidGamesWeek++;
            }

            // Timeout-Erkennung: wenn eigener result == "timeout" oder "abandoned"
            const whiteUser = g.white && g.white.username && g.white.username.toLowerCase();
            const blackUser = g.black && g.black.username && g.black.username.toLowerCase();
            const unameLower = uname;

            let myResult = null;
            if (whiteUser === unameLower) myResult = g.white.result;
            else if (blackUser === unameLower) myResult = g.black.result;

            if (myResult === "timeout" || myResult === "abandoned") {
              timeoutsWeek++;
            }

            const dayIndex = Math.floor((endMs - weekStartMs) / (24 * 60 * 60 * 1000));
            if (dayIndex >= 0 && dayIndex < 7) activeDayIndexes.add(dayIndex);
          }
        } catch (e) {
          console.error("Fehler beim Laden des Monatsarchivs", year, monthStr, "f√ºr", username, e);
        }
      }

      const activeDaysCount = activeDayIndexes.size;

      return {
        totalGamesWeek,
        rapidGamesWeek,
        activeDaysCount,
        timeoutsWeek
      };
    }

    function getMonthsBetween(startDate, endDate) {
      const months = [];
      let year = startDate.getFullYear();
      let month = startDate.getMonth() + 1; // 1-12

      while (year < endDate.getFullYear() || (year === endDate.getFullYear() && month <= endDate.getMonth() + 1)) {
        months.push({ year, month });
        month++;
        if (month > 12) {
          month = 1;
          year++;
        }
      }
      return months;
    }

    // === Weekly Activity: Firestore-Dokument ===
    async function loadWeeklyDoc(username, weekKey) {
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      const snap = await getDoc(ref);

      if (!snap.exists()) {
        const initData = {
          username,
          weekKey,
          goalsPaid: [],
          totalPaid: 0,
          pendingClaim: null,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        };
        await setDoc(ref, initData);
        return initData;
      }

      return snap.data();
    }

    // === Weekly Activity: State berechnen ===
    function computeWeeklyState(username, weeklyStats, weeklyDoc, weekKey) {
      const isChef = username === CHEF_USERNAME;
      const goalsPaid = weeklyDoc.goalsPaid || [];
      const totalPaid = weeklyDoc.totalPaid || 0;
      const pending = weeklyDoc.pendingClaim || null;

      const goalStates = WEEKLY_GOALS.map(goal => {
        let fulfilled = false;

        if (goal.id === "rapid10") {
          fulfilled = weeklyStats.rapidGamesWeek >= 10;
        } else if (goal.id === "games20") {
          fulfilled = weeklyStats.totalGamesWeek >= 20;
        } else if (goal.id === "days5") {
          fulfilled = weeklyStats.activeDaysCount >= 5;
        } else if (goal.id === "days7") {
          fulfilled = weeklyStats.activeDaysCount >= 7;
        } else if (goal.id === "noTimeouts") {
          fulfilled = weeklyStats.totalGamesWeek > 0 && weeklyStats.timeoutsWeek === 0;
        }

        const alreadyPaid = goalsPaid.includes(goal.id);

        return {
          id: goal.id,
          label: goal.label,
          amount: goal.amount,
          description: goal.description,
          fulfilled,
          alreadyPaid
        };
      });

      const potentialGoals = goalStates.filter(g => g.fulfilled && !g.alreadyPaid);
      let remainingCap = Math.max(0, WEEKLY_CAP - totalPaid);
      let claimAmount = 0;
      const claimGoalIds = [];

      for (const g of potentialGoals) {
        if (g.amount <= remainingCap) {
          claimAmount += g.amount;
          claimGoalIds.push(g.id);
          remainingCap -= g.amount;
        }
      }

      const unpaid = claimAmount;
      const rawEarned = totalPaid + potentialGoals.reduce((s, g) => s + g.amount, 0);

      return {
        isChef,
        weekKey,
        weeklyStats,
        goalStates,
        totalPaid,
        unpaid,
        rawEarned,
        pending,
        claimPlan: {
          amount: claimAmount,
          goalIds: claimGoalIds
        }
      };
    }

    async function createWeeklyClaim(username, weeklyState) {
      const { claimPlan, weekKey } = weeklyState;
      if (claimPlan.amount <= 0) return;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);

      const pendingClaim = {
        status: "requested",
        amount: claimPlan.amount,
        goals: claimPlan.goalIds,
        createdAt: serverTimestamp()
      };

      await updateDoc(ref, {
        pendingClaim,
        updatedAt: serverTimestamp()
      });
    }

    async function markWeeklyClaimPaid(username, weeklyState) {
      const { weekKey } = weeklyState;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      const pending = weeklyState.pending;
      if (!pending || pending.status !== "requested") return;

      const snap = await getDoc(ref);
      if (!snap.exists()) return;
      const data = snap.data();

      const goalsPaid = data.goalsPaid || [];
      const totalPaid = data.totalPaid || 0;

      const newGoalsPaid = Array.from(new Set([...goalsPaid, ...(pending.goals || [])]));
      const newTotalPaid = totalPaid + (pending.amount || 0);

      await updateDoc(ref, {
        goalsPaid: newGoalsPaid,
        totalPaid: newTotalPaid,
        pendingClaim: {
          ...pending,
          status: "paid",
          resolvedAt: serverTimestamp()
        },
        updatedAt: serverTimestamp()
      });
    }

    async function resetWeeklyClaim(username, weeklyState) {
      const { weekKey } = weeklyState;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      await updateDoc(ref, {
        pendingClaim: null,
        updatedAt: serverTimestamp()
      });
    }

    // === Achievements & Fokus (Lebenszeit) ===
    function buildAchievements(stats, rewardState) {
      const { totalGames, modes, tactics } = stats;
      const { total } = rewardState;
      const ach = [];

      if (totalGames === 0) {
        ach.push({ label: "üò¥ AFK", style: "fail", title: "Noch keine Partien ‚Äì perfekte Gelegenheit f√ºr ein Comeback." });
      } else if (totalGames >= 200) {
        ach.push({ label: "üß± Iron Grinder", style: "gold", title: `${totalGames} Gesamtpartien.` });
      } else if (totalGames >= 100) {
        ach.push({ label: "üèÉ Grinder", style: "silver", title: `${totalGames} Gesamtpartien.` });
      } else if (totalGames >= 50) {
        ach.push({ label: "üéØ Warmgelaufen", style: "bronze", title: `${totalGames} Gesamtpartien.` });
      }

      const modesWithGames = modes.filter(m => m.games >= 20 && m.winrate != null);
      if (modesWithGames.length) {
        modesWithGames.sort((a, b) => b.winrate - a.winrate);
        const best = modesWithGames[0];
        if (best.winrate >= 60) {
          ach.push({
            label: `üî• ${best.label}-Boss`,
            style: "gold",
            title: `Winrate ${best.winrate}% in ${best.label}.`
          });
        }
      }

      if (total.raw >= 50) {
        ach.push({
          label: "üí∂ Reward Hunter",
          style: "silver",
          title: `Schon ${total.raw} ‚Ç¨ an m√∂glichen Belohnungen freigespielt.`
        });
      }

      if (tactics && tactics.current != null && tactics.current >= 2200) {
        ach.push({
          label: "üß† Tactics Monster",
          style: "gold",
          title: `Taktikwertung ${tactics.current}.`
        });
      }

      return ach.slice(0, 3);
    }

    function buildFocus(stats, rewardState) {
      const { modes, tactics } = stats;
      const { rapid, tactics: tState } = rewardState;

      if (rapid.unpaid > 0) {
        return {
          title: "Rapid pushen",
          text: `Du hast noch <strong>${rapid.unpaid} ‚Ç¨</strong> Rapid-Belohnungen offen. Spiel ein paar konzentrierte Rapid-Partien.`
        };
      }

      if (tState.unpaid > 0) {
        return {
          title: "Taktikblock",
          text: `Mit ein paar Taktik-Sessions kannst du weitere <strong>${tState.unpaid} ‚Ç¨</strong> freischalten.`
        };
      }

      if (tactics && tactics.current != null) {
        return {
          title: "Mini-Taktikblock",
          text: `Mach zuerst 10‚Äì15 Taktikaufgaben um deine aktuelle Wertung (${tactics.current}) herum, dann ab an die Bretter.`
        };
      }

      return {
        title: "Einfach spielen",
        text: "Such dir ein Zeitformat, das dir Spa√ü macht, und spiel ein paar ruhige, konzentrierte Partien."
      };
    }

    // === Rendering ===
    function renderPlayerCard(stats, rewardState, weeklyState) {
      const cards = document.getElementById("cards");
      const card = document.createElement("article");
      card.className = "card";

      const header = document.createElement("div");
      header.className = "card-header";

      const left = document.createElement("div");
      left.className = "card-title-block";

      if (stats.avatar) {
        const img = document.createElement("img");
        img.src = stats.avatar;
        img.alt = stats.username;
        img.className = "avatar";
        left.appendChild(img);
      }

      const nameEl = document.createElement("div");
      nameEl.className = "username";
      nameEl.textContent = stats.username;
      left.appendChild(nameEl);

      header.appendChild(left);

      const status = document.createElement("div");
      status.className = "status-badge " + (stats.active ? "status-active" : "status-chill");
      status.textContent = stats.active ? "AKTIV" : "PAUSE";
      header.appendChild(status);

      card.appendChild(header);

      // Ratings
      const modesTitle = document.createElement("div");
      modesTitle.className = "section-title";
      modesTitle.textContent = "Ratings & Bestleistungen";
      card.appendChild(modesTitle);

      const modesWrap = document.createElement("div");
      modesWrap.className = "modes";

      if (!stats.modes.length) {
        const p = document.createElement("div");
        p.style.fontSize = "0.78rem";
        p.style.color = "#9ca3af";
        p.textContent = "Keine Partiedaten verf√ºgbar.";
        modesWrap.appendChild(p);
      } else {
        stats.modes.forEach(m => {
          const row = document.createElement("div");
          row.className = "mode-row";

          const leftCol = document.createElement("div");
          leftCol.className = "mode-left";

          const label = document.createElement("div");
          label.className = "mode-label";
          label.innerHTML = `${m.icon} ${m.label}`;
          leftCol.appendChild(label);

          const meta = document.createElement("div");
          meta.className = "mode-meta";
          const winrateText = m.winrate != null ? `${m.winrate}%` : "‚Äì";
          meta.textContent = `${m.games} Partien ¬∑ Winrate ${winrateText}`;
          leftCol.appendChild(meta);

          const rightCol = document.createElement("div");
          rightCol.className = "mode-right";

          const current = document.createElement("div");
          current.innerHTML = `<span class="rating">${m.current ?? "‚Äì"}</span>`;
          rightCol.appendChild(current);

          const gapText = document.createElement("div");
          if (m.best != null && m.current != null) {
            const gap = m.best - m.current;
            let cls = "gap-mid";
            let labelText = "";
            if (gap <= 0) {
              cls = "gap-good";
              labelText = "Neue PB!";
            } else if (gap <= 20) {
              cls = "gap-good";
              labelText = `${gap} bis PB`;
            } else if (gap <= 80) {
              cls = "gap-mid";
              labelText = `${gap} bis PB`;
            } else {
              cls = "gap-bad";
              labelText = `${gap} unter PB`;
            }
            gapText.innerHTML = `<span class="${cls}">${labelText}</span>`;
          } else {
            gapText.textContent = "‚Äî";
          }
          rightCol.appendChild(gapText);

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          modesWrap.appendChild(row);
        });
      }

      card.appendChild(modesWrap);

      // Badges
      const achTitle = document.createElement("div");
      achTitle.className = "section-title";
      achTitle.textContent = "Badges";
      card.appendChild(achTitle);

      const achRow = document.createElement("div");
      achRow.className = "badge-row";
      const achievements = buildAchievements(stats, rewardState);

      if (!achievements.length) {
        const span = document.createElement("span");
        span.style.color = "#9ca3af";
        span.style.fontSize = "0.75rem";
        span.textContent = "Spiel ein bisschen mehr, um Badges freizuschalten.";
        achRow.appendChild(span);
      } else {
        achievements.forEach(a => {
          const span = document.createElement("span");
          span.className = `badge ${a.style}`;
          span.textContent = a.label;
          if (a.title) span.title = a.title;
          achRow.appendChild(span);
        });
      }
      card.appendChild(achRow);

      // Fokus
      const focusTitle = document.createElement("div");
      focusTitle.className = "section-title";
      focusTitle.textContent = "Heutiger Fokus";
      card.appendChild(focusTitle);

      const focusInfo = buildFocus(stats, rewardState);
      const focus = document.createElement("div");
      focus.className = "focus";
      focus.innerHTML = `<strong>${focusInfo.title}</strong><br>${focusInfo.text}`;
      card.appendChild(focus);

      // Lebenszeit-Belohnungen ‚Äì NICHT f√ºr M41K
      if (!rewardState.isChef) {
        const rewardTitle = document.createElement("div");
        rewardTitle.className = "section-title";
        rewardTitle.textContent = "Belohnungen & Progression (Lebenszeit)";
        card.appendChild(rewardTitle);

        const rewardBox = document.createElement("div");
        rewardBox.className = "focus";

        const { tactics, rapid, total, pending, claimable } = rewardState;
        const activePending = pending && pending.status === "requested" ? pending : null;

        rewardBox.innerHTML = `
          <div class="reward-row">
            <span class="reward-label">Gesamt erspielt (theoretisch):</span>
            <span class="reward-value">${total.raw} ‚Ç¨</span>
            <span class="reward-label">Bereits ausgezahlt:</span>
            <span class="reward-value">${total.paid} ‚Ç¨</span>
            <span class="reward-label">Noch offen:</span>
            <span class="reward-value">${total.unpaid} ‚Ç¨</span>
          </div>
          <hr style="border:none;border-top:1px solid #1f2937;margin:0.5rem 0;">
          <div class="reward-row">
            <span class="reward-label">Taktik (√ºber ${rewardState.baselineT}):</span>
            <span class="reward-value">${tactics.rewardRaw} ‚Ç¨</span>
            <span class="reward-label">Rapid (√ºber ${rewardState.baselineR}):</span>
            <span class="reward-value">${rapid.rewardRaw} ‚Ç¨</span>
          </div>
        `;

        const chip = document.createElement("div");
        let chipClass, chipText;
        if (activePending) {
          chipClass = "chip-requested";
          chipText = `Anfrage offen: ${activePending.amount} ‚Ç¨ ‚Äì wartet darauf, als ausgezahlt markiert zu werden.`;
        } else if (total.unpaid > 0) {
          chipClass = "chip-open";
          chipText = `Noch nicht angefordert: ${total.unpaid} ‚Ç¨.`;
        } else {
          chipClass = "chip-paid";
          chipText = "Alle erreichbaren Belohnungen sind aktuell als ausgezahlt markiert.";
        }
        chip.className = `reward-chip ${chipClass}`;
        chip.textContent = chipText;
        rewardBox.appendChild(chip);

        if (!activePending && total.unpaid > 0) {
          const btn = document.createElement("button");
          btn.className = "btn";
          btn.textContent = `Belohnung einfordern (${total.unpaid} ‚Ç¨)`;
          btn.addEventListener("click", async () => {
            btn.disabled = true;
            await createLifetimeClaim(stats.username, rewardState);
            location.reload();
          });
          rewardBox.appendChild(btn);
        } else if (activePending) {
          const btnPaid = document.createElement("button");
          btnPaid.className = "btn";
          btnPaid.textContent = `Ausgezahlt (${activePending.amount} ‚Ç¨)`;
          btnPaid.addEventListener("click", async () => {
            btnPaid.disabled = true;
            await markLifetimeClaimPaid(stats.username, rewardState);
            location.reload();
          });
          rewardBox.appendChild(btnPaid);

          const btnCancel = document.createElement("button");
          btnCancel.className = "btn btn-danger";
          btnCancel.textContent = "Anfrage zur√ºcksetzen";
          btnCancel.addEventListener("click", async () => {
            btnCancel.disabled = true;
            await resetLifetimeClaim(stats.username);
            location.reload();
          });
          rewardBox.appendChild(btnCancel);
        }

        card.appendChild(rewardBox);
      }

      // Weekly Activity ‚Äì auch NICHT f√ºr M41K
      if (!weeklyState.isChef) {
        const weeklyTitle = document.createElement("div");
        weeklyTitle.className = "section-title";
        weeklyTitle.textContent = "W√∂chentlicher Aktivit√§tsbonus";
        card.appendChild(weeklyTitle);

        const weeklyBox = document.createElement("div");
        weeklyBox.className = "focus";

        const { weeklyStats, goalStates, unpaid, totalPaid, pending, claimPlan, weekKey } = weeklyState;
        const activePending = pending && pending.status === "requested" ? pending : null;

        weeklyBox.innerHTML = `
          <div style="font-size:0.78rem;margin-bottom:0.3rem;">
            Woche: <strong>${weekKey}</strong><br>
            Diese Woche bisher: ${weeklyStats.totalGamesWeek} Partien (${weeklyStats.rapidGamesWeek} Rapid) ¬∑ an ${weeklyStats.activeDaysCount}/7 Tagen aktiv ¬∑ Timeouts: ${weeklyStats.timeoutsWeek}
          </div>
          <div class="reward-row">
            <span class="reward-label">Bereits ausgezahlt (Woche):</span>
            <span class="reward-value">${totalPaid} ‚Ç¨</span>
            <span class="reward-label">Noch m√∂glich (Cap ${WEEKLY_CAP} ‚Ç¨):</span>
            <span class="reward-value">${unpaid} ‚Ç¨</span>
          </div>
        `;

        const goalsDiv = document.createElement("div");
        goalsDiv.className = "weekly-goals";

        goalStates.forEach(g => {
          const row = document.createElement("div");
          row.className = "weekly-goal-row";

          const leftCol = document.createElement("div");
          leftCol.className = "weekly-goal-label";
          const name = document.createElement("div");
          name.className = "weekly-goal-name";
          name.textContent = `${g.label} (${g.amount} ‚Ç¨)`;
          const meta = document.createElement("div");
          meta.className = "weekly-goal-meta";
          meta.textContent = g.description;
          leftCol.appendChild(name);
          leftCol.appendChild(meta);

          const rightCol = document.createElement("div");
          rightCol.className = "weekly-goal-status";

          if (g.alreadyPaid) {
            rightCol.innerHTML = `<span class="status-paid">‚úî bereits bezahlt</span>`;
          } else if (g.fulfilled) {
            rightCol.innerHTML = `<span class="status-ok">‚úî erreicht</span>`;
          } else {
            rightCol.innerHTML = `<span class="status-missing">noch nicht erf√ºllt</span>`;
          }

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          goalsDiv.appendChild(row);
        });

        weeklyBox.appendChild(goalsDiv);

        const chip = document.createElement("div");
        let chipClass, chipText;
        if (activePending) {
          chipClass = "chip-requested";
          chipText = `Weekly-Anfrage offen: ${activePending.amount} ‚Ç¨ ‚Äì wartet darauf, als ausgezahlt markiert zu werden.`;
        } else if (unpaid > 0) {
          chipClass = "chip-open";
          chipText = `Du kannst diese Woche noch ${unpaid} ‚Ç¨ Aktivit√§tsbonus einfordern.`;
        } else {
          chipClass = "chip-paid";
          chipText = "F√ºr diese Woche ist aktuell kein weiterer Aktivit√§tsbonus offen.";
        }
        chip.className = `reward-chip ${chipClass}`;
        chip.textContent = chipText;
        weeklyBox.appendChild(chip);

        if (!activePending && claimPlan.amount > 0) {
          const btn = document.createElement("button");
          btn.className = "btn";
          btn.textContent = `W√∂chentlichen Bonus einfordern (${claimPlan.amount} ‚Ç¨)`;
          btn.addEventListener("click", async () => {
            btn.disabled = true;
            await createWeeklyClaim(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btn);
        } else if (activePending) {
          const btnPaid = document.createElement("button");
          btnPaid.className = "btn";
          btnPaid.textContent = `Ausgezahlt (${activePending.amount} ‚Ç¨)`;
          btnPaid.addEventListener("click", async () => {
            btnPaid.disabled = true;
            await markWeeklyClaimPaid(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btnPaid);

          const btnCancel = document.createElement("button");
          btnCancel.className = "btn btn-danger";
          btnCancel.textContent = "Anfrage zur√ºcksetzen";
          btnCancel.addEventListener("click", async () => {
            btnCancel.disabled = true;
            await resetWeeklyClaim(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btnCancel);
        }

        card.appendChild(weeklyBox);
      }

      cards.appendChild(card);
    }

    function renderSquad(players) {
      const container = document.getElementById("squad");
      container.innerHTML = "";

      const card = document.createElement("div");
      card.className = "squad-card";

      const title = document.createElement("div");
      title.className = "squad-title";
      title.innerHTML = "üí¨ Squad-√úbersicht";
      card.appendChild(title);

      const list = document.createElement("div");
      list.className = "squad-list";

      const allModes = [];
      players.forEach(p => p.stats.modes.forEach(m => allModes.push({ player: p.stats.username, ...m })));
      const rapid = allModes.filter(m => m.key === "chess_rapid" && m.current != null);
      if (rapid.length) {
        rapid.sort((a, b) => b.current - a.current);
        const r = rapid[0];
        list.innerHTML += `<div>üèÜ H√∂chstes Rapid-Rating: <strong>${r.player}</strong> (${r.current}).</div>`;
      }

      const activeCount = players.filter(p => p.stats.active).length;
      list.innerHTML += `<div>üìÜ Aktuell aktiv: <strong>${activeCount}/${players.length}</strong>.</div>`;

      card.appendChild(list);
      container.appendChild(card);
    }

    // === Init ===
    async function init() {
      const subtitle = document.getElementById("subtitle");
      subtitle.textContent = "Lade Daten von Chess.com & Firestore‚Ä¶";

      const { weekKey } = getCurrentWeekRange();
      const playersCombined = [];

      for (const name of PLAYERS) {
        try {
          const stats = await loadChessStats(name);
          const [rewardDoc, weeklyStats, weeklyDoc] = await Promise.all([
            loadRewardDoc(name, stats.tacticsRating, stats.rapidRating),
            loadWeeklyStats(name),
            loadWeeklyDoc(name, weekKey)
          ]);

          const rewardState = computeRewardState(name, stats.tacticsRating, stats.rapidRating, rewardDoc);
          const weeklyState = computeWeeklyState(name, weeklyStats, weeklyDoc, weekKey);

          playersCombined.push({ stats, rewardState, weeklyState });
          renderPlayerCard(stats, rewardState, weeklyState);
        } catch (e) {
          console.error("Fehler bei Spieler", name, e);
        }
      }

      renderSquad(playersCombined);

      const now = new Date();
      subtitle.textContent = `Live-Stand ¬∑ aktualisiert am ${now.toLocaleString()}`;
    }

    init();
  </script>
</body>
</html>