<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Squad ‚Äì Motivation Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);
      color: #e5e7eb;
    }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1.25rem 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    main {
      width: 100%;
      max-width: 1100px;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(2rem, 3vw, 2.5rem);
      text-align: center;
    }

    .subtitle {
      color: #9ca3af;
      font-size: 0.9rem;
      text-align: center;
      margin-top: 0.5rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: rgba(31,41,55,0.7);
      border: 1px solid #1f2937;
      color: #e5e7eb;
    }

    /* Layout */
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(270px, 1fr));
      gap: 1.5rem;
      width: 100%;
    }

    .card {
      background: radial-gradient(circle at top, #111827, #020617);
      border-radius: 1rem;
      padding: 1.2rem 1.4rem 1.3rem;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 45px rgba(0,0,0,0.6);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 0.6rem;
    }

    .card-title-block {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .avatar {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 2px solid #22c55e;
      object-fit: cover;
      background: #020617;
      flex-shrink: 0;
    }

    .username {
      font-weight: 600;
      font-size: 1.05rem;
    }

    .status-badge {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .status-active {
      background: #065f46;
      color: #bbf7d0;
    }

    .status-chill {
      background: #7f1d1d;
      color: #fecaca;
    }

    .section-title {
      margin-top: 0.7rem;
      font-size: 0.82rem;
      font-weight: 600;
      color: #d1d5db;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .modes {
      margin-top: 0.3rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.78rem;
    }

    .mode-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.6rem;
      background: rgba(15,23,42,0.7);
    }

    .mode-left {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }

    .mode-label {
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .mode-meta {
      color: #9ca3af;
      font-size: 0.72rem;
    }

    .mode-right {
      text-align: right;
      font-size: 0.76rem;
    }

    .rating {
      font-weight: 600;
      color: #facc15;
    }

    .gap-good {
      color: #22c55e;
    }
    .gap-mid {
      color: #eab308;
    }
    .gap-bad {
      color: #f97316;
    }

    .badge-row {
      margin-top: 0.4rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      font-size: 0.72rem;
    }

    .badge {
      padding: 0.18rem 0.55rem;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      white-space: nowrap;
      cursor: default;
    }

    .badge.gold {
      border-color: #fbbf24;
      color: #facc15;
    }

    .badge.silver {
      border-color: #9ca3af;
      color: #e5e7eb;
    }

    .badge.bronze {
      border-color: #f97316;
      color: #fed7aa;
    }

    .badge.fail {
      border-color: #ef4444;
      color: #fecaca;
    }

    .focus {
      margin-top: 0.6rem;
      font-size: 0.8rem;
      line-height: 1.4;
      padding: 0.45rem 0.55rem;
      border-radius: 0.6rem;
      background: rgba(15,23,42,0.85);
      border: 1px dashed #1f2937;
      color: #e5e7eb;
    }

    .focus strong {
      color: #a5b4fc;
    }

    /* Squad section */
    .squad-card {
      background: #020617;
      border-radius: 0.9rem;
      border: 1px solid #1f2937;
      padding: 1rem 1.2rem;
    }

    .squad-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .squad-list {
      font-size: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    footer {
      font-size: 0.75rem;
      color: #6b7280;
      text-align: center;
      margin-top: 1.5rem;
    }

    a {
      color: #60a5fa;
    }
  </style>
</head>
<body>
  <main>
    <header style="text-align:center;">
      <h1>‚ôüÔ∏è Chess Squad Motivation Board</h1>
      <p class="subtitle" id="subtitle">
        Loading live stats from Chess.com‚Ä¶
      </p>
    </header>

    <!-- Player cards -->
    <section class="grid" id="cards"></section>

    <!-- Squad goals / simple leaderboard -->
    <section id="squad"></section>

    <footer>
      Data from the <a href="https://www.chess.com/news/view/published-data-api" target="_blank" rel="noreferrer">Chess.com Published Data API</a> ¬∑ Have fun & don‚Äôt tilt ‚ô•
    </footer>
  </main>

  <script>
    // === CONFIG ===
    const PLAYERS = ["ERR_Daemon", "M41K", "Kathi_2905"];
    const MODES = [
      { key: "chess_rapid", label: "Rapid", icon: "‚è±Ô∏è" },
      { key: "chess_blitz", label: "Blitz", icon: "‚ö°" },
      { key: "chess_bullet", label: "Bullet", icon: "üí£" },
      { key: "chess_daily", label: "Daily", icon: "üì¨" },
    ];

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error("HTTP " + res.status + " for " + url);
      return res.json();
    }

    async function loadPlayer(username) {
      const uname = username.toLowerCase();
      const [profile, stats] = await Promise.allSettled([
        fetchJson(`https://api.chess.com/pub/player/${uname}`),
        fetchJson(`https://api.chess.com/pub/player/${uname}/stats`)
      ]);

      const profileData = profile.status === "fulfilled" ? profile.value : {};
      const statsData   = stats.status === "fulfilled"   ? stats.value   : {};

      const modes = MODES.map(m => extractMode(statsData, m.key, m.label, m.icon))
        .filter(Boolean);

      const tactics = extractTactics(statsData);
      const puzzles = extractPuzzleRush(statsData);

      const totalGames = modes.reduce((sum, m) => sum + m.games, 0);
      const active = totalGames > 0;

      const achievements = buildAchievements({ username, totalGames, modes, tactics, puzzles });
      const focus = buildFocusSuggestion(modes, tactics, puzzles);

      return {
        username,
        avatar: profileData.avatar || null,
        url: profileData.url || null,
        modes,
        tactics,
        puzzles,
        totalGames,
        active,
        achievements,
        focus
      };
    }

    function extractMode(stats, key, label, icon) {
      const s = stats[key];
      if (!s || !s.last || !s.record) return null;

      const current = s.last.rating ?? null;
      const best    = s.best && s.best.rating != null ? s.best.rating : null;
      const rec     = s.record || {};
      const wins  = rec.win   || 0;
      const loss  = rec.loss  || 0;
      const draw  = rec.draw  || 0;
      const games = wins + loss + draw;
      const winrate = games ? Math.round((wins / games) * 100) : null;
      const gap = (best != null && current != null) ? best - current : null;

      return {
        key,
        label,
        icon,
        current,
        best,
        wins,
        loss,
        draw,
        games,
        winrate,
        gap
      };
    }

    function extractTactics(stats) {
      const t = stats.tactics;
      if (!t) return null;
      const last    = t.last || {};
      const highest = t.highest || {};
      const lowest  = t.lowest || {};
      const current = last.rating ?? highest.rating ?? null;
      return {
        current,
        highest: highest.rating ?? null,
        lowest: lowest.rating ?? null
      };
    }

    function extractPuzzleRush(stats) {
      const p = stats.puzzle_rush;
      if (!p) return null;
      const best  = p.best || {};
      const daily = p.daily || {};
      return {
        bestScore: best.score ?? null,
        bestAttempts: best.total_attempts ?? null,
        todayScore: daily.score ?? null,
        todayAttempts: daily.total_attempts ?? null
      };
    }

    // === Achievements & Focus ===
    function buildAchievements(player) {
      const { totalGames, modes, tactics, puzzles } = player;
      const ach = [];

      // Volume
      if (totalGames === 0) {
        ach.push({ label: "üò¥ AFK", style: "fail", title: "No games yet ‚Äì time for a comeback." });
      } else if (totalGames >= 200) {
        ach.push({ label: "üß± Iron Grinder", style: "gold", title: `${totalGames} total games.` });
      } else if (totalGames >= 100) {
        ach.push({ label: "üèÉ‚Äç‚ôÇÔ∏è Grinder", style: "silver", title: `${totalGames} total games.` });
      } else if (totalGames >= 50) {
        ach.push({ label: "üéØ Warmed Up", style: "bronze", title: `${totalGames} total games.` });
      }

      // Best winrate mode
      const modesWithGames = modes.filter(m => m.games >= 20 && m.winrate != null);
      if (modesWithGames.length) {
        modesWithGames.sort((a, b) => b.winrate - a.winrate);
        const best = modesWithGames[0];
        if (best.winrate >= 60) {
          ach.push({
            label: `üî• ${best.label} Boss`,
            style: "gold",
            title: `Winrate ${best.winrate}% in ${best.label}.`
          });
        } else if (best.winrate >= 55) {
          ach.push({
            label: `üí™ ${best.label} Climber`,
            style: "silver",
            title: `Winrate ${best.winrate}% in ${best.label}.`
          });
        }
      }

      // Comeback or PB close
      for (const m of modes) {
        if (m.current != null && m.best != null && m.games >= 30) {
          const gap = m.gap;
          if (gap != null && gap <= 20 && gap >= 0) {
            ach.push({
              label: `üèÅ PB Chase (${m.label})`,
              style: "bronze",
              title: `Only ${gap} Elo from your ${m.label} peak.`
            });
            break;
          }
        }
      }

      // Tactics / puzzles
      if (tactics && tactics.current != null) {
        if (tactics.current >= 2200) {
          ach.push({ label: "üß† Tactics Monster", style: "gold", title: `Tactics ${tactics.current}.` });
        } else if (tactics.current >= 1800) {
          ach.push({ label: "üß© Tactics Pro", style: "silver", title: `Tactics ${tactics.current}.` });
        } else if (tactics.current >= 1400) {
          ach.push({ label: "üìö Tactics Student", style: "bronze", title: `Tactics ${tactics.current}.` });
        }
      }

      if (puzzles && puzzles.bestScore != null) {
        if (puzzles.bestScore >= 40) {
          ach.push({ label: "‚ö° Rush Demon", style: "gold", title: `Puzzle Rush best ${puzzles.bestScore}.` });
        } else if (puzzles.bestScore >= 30) {
          ach.push({ label: "‚ö° Rush Grinder", style: "silver", title: `Puzzle Rush best ${puzzles.bestScore}.` });
        }
      }

      return ach.slice(0, 3); // only most important
    }

    function buildFocusSuggestion(modes, tactics, puzzles) {
      // 1. Mode where you‚Äôre furthest below PB
      let worstGap = null;
      let gapMode = null;
      for (const m of modes) {
        if (m.gap != null && m.gap > 0 && m.games >= 20) {
          if (worstGap == null || m.gap > worstGap) {
            worstGap = m.gap;
            gapMode = m;
          }
        }
      }

      if (gapMode && worstGap >= 30) {
        return {
          title: `Grind ${gapMode.label}`,
          text: `You are <strong>${worstGap} Elo</strong> below your best ${gapMode.label} rating. Play a focused mini-session (e.g. 3‚Äì5 games) and see if you can close the gap today.`
        };
      }

      // 2. Mode with highest winrate but not many games ‚Üí "play more"
      const sortedByWR = modes
        .filter(m => m.winrate != null && m.games >= 5)
        .sort((a, b) => b.winrate - a.winrate);

      if (sortedByWR.length) {
        const m = sortedByWR[0];
        if (m.winrate >= 60 && m.games < 80) {
          return {
            title: `${m.label} is your weapon`,
            text: `Your winrate in <strong>${m.label}</strong> is ${m.winrate}%. That‚Äôs your comfort zone ‚Äì queue up a streak there and farm confidence.`
          };
        }
      }

      // 3. Tactics / Puzzle focus
      if (tactics && tactics.current != null) {
        return {
          title: "Tactics first",
          text: `Do a short tactics block: aim for <strong>10‚Äì15 good puzzles</strong> around your rating (${tactics.current}). Then play ‚Äì your calculation will feel much sharper.`
        };
      }

      if (puzzles && puzzles.todayAttempts != null) {
        return {
          title: "Daily Rush",
          text: `You‚Äôve done <strong>${puzzles.todayAttempts}</strong> Puzzle Rush attempts today. Try one more run and beat today‚Äôs score${
            puzzles.todayScore != null ? " (" + puzzles.todayScore + ")." : "."
          }`
        };
      }

      return {
        title: "Just play",
        text: "No clear weak spot detected ‚Äì pick any mode you enjoy and get a few games in together."
      };
    }

    // === Rendering ===
    function renderPlayerCard(player) {
      const cards = document.getElementById("cards");

      const card = document.createElement("article");
      card.className = "card";

      const header = document.createElement("div");
      header.className = "card-header";

      const left = document.createElement("div");
      left.className = "card-title-block";

      if (player.avatar) {
        const img = document.createElement("img");
        img.src = player.avatar;
        img.alt = player.username;
        img.className = "avatar";
        left.appendChild(img);
      }

      const nameEl = document.createElement("div");
      nameEl.className = "username";
      nameEl.textContent = player.username;
      left.appendChild(nameEl);

      header.appendChild(left);

      const status = document.createElement("div");
      status.className = "status-badge " + (player.active ? "status-active" : "status-chill");
      status.textContent = player.active ? "ACTIVE" : "CHILLING";
      header.appendChild(status);

      card.appendChild(header);

      // Modes
      const modesTitle = document.createElement("div");
      modesTitle.className = "section-title";
      modesTitle.textContent = "Ratings & personal bests";
      card.appendChild(modesTitle);

      const modesWrap = document.createElement("div");
      modesWrap.className = "modes";

      if (!player.modes.length) {
        const p = document.createElement("div");
        p.style.fontSize = "0.78rem";
        p.style.color = "#9ca3af";
        p.textContent = "No mode stats available in the API.";
        modesWrap.appendChild(p);
      } else {
        player.modes.forEach(m => {
          const row = document.createElement("div");
          row.className = "mode-row";

          const leftCol = document.createElement("div");
          leftCol.className = "mode-left";

          const label = document.createElement("div");
          label.className = "mode-label";
          label.innerHTML = `${m.icon} ${m.label}`;
          leftCol.appendChild(label);

          const meta = document.createElement("div");
          meta.className = "mode-meta";
          const winrateText = m.winrate != null ? `${m.winrate}%` : "‚Äì";
          meta.textContent = `${m.games} games ¬∑ Winrate ${winrateText}`;
          leftCol.appendChild(meta);

          const rightCol = document.createElement("div");
          rightCol.className = "mode-right";

          const current = document.createElement("div");
          current.innerHTML = `<span class="rating">${m.current ?? "‚Äì"}</span>`;
          rightCol.appendChild(current);

          const gapText = document.createElement("div");
          if (m.best != null && m.current != null) {
            const gap = m.best - m.current;
            let cls = "gap-mid";
            let label = "";
            if (gap <= 0) {
              cls = "gap-good";
              label = "New PB!";
            } else if (gap <= 20) {
              cls = "gap-good";
              label = `${gap} to PB`;
            } else if (gap <= 80) {
              cls = "gap-mid";
              label = `${gap} to PB`;
            } else {
              cls = "gap-bad";
              label = `${gap} behind PB`;
            }
            gapText.innerHTML = `<span class="${cls}">${label}</span>`;
          } else {
            gapText.textContent = "‚Äî";
          }
          rightCol.appendChild(gapText);

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          modesWrap.appendChild(row);
        });
      }

      card.appendChild(modesWrap);

      // Achievements
      const achTitle = document.createElement("div");
      achTitle.className = "section-title";
      achTitle.textContent = "Badges";
      card.appendChild(achTitle);

      const achRow = document.createElement("div");
      achRow.className = "badge-row";

      if (!player.achievements.length) {
        const span = document.createElement("span");
        span.style.color = "#9ca3af";
        span.style.fontSize = "0.75rem";
        span.textContent = "Play a bit more to unlock badges.";
        achRow.appendChild(span);
      } else {
        player.achievements.forEach(a => {
          const span = document.createElement("span");
          span.className = `badge ${a.style}`;
          span.textContent = a.label;
          if (a.title) span.title = a.title;
          achRow.appendChild(span);
        });
      }

      card.appendChild(achRow);

      // Focus block
      const focusTitle = document.createElement("div");
      focusTitle.className = "section-title";
      focusTitle.textContent = "Today‚Äôs focus";
      card.appendChild(focusTitle);

      const focus = document.createElement("div");
      focus.className = "focus";
      focus.innerHTML = `<strong>${player.focus.title}</strong><br>${player.focus.text}`;
      card.appendChild(focus);

      cards.appendChild(card);
    }

    function renderSquad(players) {
      const container = document.getElementById("squad");
      container.innerHTML = "";

      const card = document.createElement("div");
      card.className = "squad-card";

      const title = document.createElement("div");
      title.className = "squad-title";
      title.innerHTML = "üí¨ Squad goals";
      card.appendChild(title);

      const list = document.createElement("div");
      list.className = "squad-list";

      // Highest rapid
      const allModes = [];
      players.forEach(p => p.modes.forEach(m => allModes.push({ player: p.username, ...m })));

      const rapid = allModes.filter(m => m.key === "chess_rapid" && m.current != null);
      if (rapid.length) {
        rapid.sort((a, b) => b.current - a.current);
        const r = rapid[0];
        const nextMilestone = nextRatingMilestone(r.current);
        list.innerHTML += `<div>üèÜ Highest Rapid: <strong>${r.player}</strong> (${r.current}). Next shared target: <strong>${nextMilestone}</strong> Rapid for everyone.</div>`;
      }

      // Tactics king
      const tacticsPlayers = players.filter(p => p.tactics && p.tactics.current != null);
      if (tacticsPlayers.length) {
        tacticsPlayers.sort((a, b) => b.tactics.current - a.tactics.current);
        const t = tacticsPlayers[0];
        list.innerHTML += `<div>üß† Tactics boss: <strong>${t.username}</strong> (${t.tactics.current}). Everyone else: do 10 puzzles and try to catch up.</div>`;
      }

      // Simple play reminder
      const activeCount = players.filter(p => p.active).length;
      list.innerHTML += `<div>ü§ù Team challenge: all <strong>${players.length}</strong> play at least <strong>3 games</strong> in your focus mode before the weekend.</div>`;
      list.innerHTML += `<div>üìÜ Currently active this week: <strong>${activeCount}/${players.length}</strong>.</div>`;

      card.appendChild(list);
      container.appendChild(card);
    }

    function nextRatingMilestone(rating) {
      if (rating == null) return "next step";
      const milestones = [1000, 1200, 1400, 1600, 1800, 2000];
      for (const m of milestones) {
        if (rating < m) return m;
      }
      return rating + 50;
    }

    async function init() {
      const subtitle = document.getElementById("subtitle");
      subtitle.textContent = "Loading from Chess.com‚Ä¶";

      const players = [];
      for (const name of PLAYERS) {
        try {
          const p = await loadPlayer(name);
          players.push(p);
        } catch (e) {
          console.error("Error loading", name, e);
        }
      }

      players.forEach(renderPlayerCard);
      renderSquad(players);

      const now = new Date();
      subtitle.textContent = `Live stats ¬∑ updated ${now.toLocaleString()}`;
    }

    init();
  </script>
</body>
</html>
