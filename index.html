<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Chess Squad ‚Äì Motivation & Belohnungen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);
      color: #e5e7eb;
    }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1.25rem 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    main {
      width: 100%;
      max-width: 1100px;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(2rem, 3vw, 2.5rem);
      text-align: center;
    }

    .subtitle {
      color: #9ca3af;
      font-size: 0.9rem;
      text-align: center;
      margin-top: 0.5rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      width: 100%;
    }

    .card {
      background: radial-gradient(circle at top, #111827, #020617);
      border-radius: 1rem;
      padding: 1.2rem 1.4rem 1.3rem;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 45px rgba(0,0,0,0.6);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 0.6rem;
    }

    .card-title-block {
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .avatar {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 2px solid #22c55e;
      object-fit: cover;
      background: #020617;
      flex-shrink: 0;
    }

    .username {
      font-weight: 600;
      font-size: 1.05rem;
    }

    .status-badge {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .status-active {
      background: #065f46;
      color: #bbf7d0;
    }

    .status-chill {
      background: #7f1d1d;
      color: #fecaca;
    }

    .section-title {
      margin-top: 0.7rem;
      font-size: 0.82rem;
      font-weight: 600;
      color: #d1d5db;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .modes {
      margin-top: 0.3rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.78rem;
    }

    .mode-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.3rem 0.4rem;
      border-radius: 0.6rem;
      background: rgba(15,23,42,0.7);
    }

    .mode-left {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }

    .mode-label {
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .mode-meta {
      color: #9ca3af;
      font-size: 0.72rem;
    }

    .mode-right {
      text-align: right;
      font-size: 0.76rem;
    }

    .rating {
      font-weight: 600;
      color: #facc15;
    }

    .gap-good {
      color: #22c55e;
    }
    .gap-mid {
      color: #eab308;
    }
    .gap-bad {
      color: #f97316;
    }

    .badge-row {
      margin-top: 0.4rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      font-size: 0.72rem;
    }

    .badge {
      padding: 0.18rem 0.55rem;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      white-space: nowrap;
      cursor: default;
    }

    .badge.gold {
      border-color: #fbbf24;
      color: #facc15;
    }

    .badge.silver {
      border-color: #9ca3af;
      color: #e5e7eb;
    }

    .badge.bronze {
      border-color: #f97316;
      color: #fed7aa;
    }

    .badge.fail {
      border-color: #ef4444;
      color: #fecaca;
    }

    .focus {
      margin-top: 0.6rem;
      font-size: 0.8rem;
      line-height: 1.4;
      padding: 0.45rem 0.55rem;
      border-radius: 0.6rem;
      background: rgba(15,23,42,0.85);
      border: 1px dashed #1f2937;
      color: #e5e7eb;
    }

    .focus strong {
      color: #a5b4fc;
    }

    .reward-row {
      margin-top: 0.4rem;
      font-size: 0.8rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      row-gap: 0.15rem;
      column-gap: 0.5rem;
    }

    .reward-label {
      color: #9ca3af;
    }

    .reward-value {
      text-align: right;
      font-weight: 600;
    }

    .reward-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.15rem 0.55rem;
      border-radius: 999px;
      font-size: 0.7rem;
      margin-top: 0.35rem;
    }

    .chip-open {
      background: rgba(234,179,8,0.15);
      border: 1px solid #eab308;
      color: #fde68a;
    }

    .chip-requested {
      background: rgba(59,130,246,0.15);
      border: 1px solid #3b82f6;
      color: #bfdbfe;
    }

    .chip-paid {
      background: rgba(34,197,94,0.15);
      border: 1px solid #22c55e;
      color: #bbf7d0;
    }

    .btn {
      margin-top: 0.5rem;
      padding: 0.35rem 0.8rem;
      border-radius: 999px;
      border: 1px solid #22c55e;
      background: #022c22;
      color: #bbf7d0;
      font-size: 0.75rem;
      cursor: pointer;
    }
    .btn:hover {
      filter: brightness(1.1);
    }

    .btn-secondary {
      border-color: #3b82f6;
      background: #0b2239;
      color: #bfdbfe;
      margin-left: 0.3rem;
    }

    .btn-danger {
      border-color: #ef4444;
      background: #450a0a;
      color: #fecaca;
      margin-left: 0.3rem;
    }

    .squad-card {
      background: #020617;
      border-radius: 0.9rem;
      border: 1px solid #1f2937;
      padding: 1rem 1.2rem;
    }

    .squad-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .squad-list {
      font-size: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    footer {
      font-size: 0.75rem;
      color: #6b7280;
      text-align: center;
      margin-top: 1.5rem;
    }

    a {
      color: #60a5fa;
    }
  </style>
</head>
<body>
  <main>
    <header style="text-align:center;">
      <h1>‚ôüÔ∏è Chess Squad ‚Äì Motivation & Belohnungen</h1>
      <p class="subtitle" id="subtitle">
        Lade Live-Daten von Chess.com‚Ä¶
      </p>
    </header>

    <section class="grid" id="cards"></section>
    <section id="squad"></section>

    <footer>
      Datenquelle: <a href="https://www.chess.com/news/view/published-data-api" target="_blank" rel="noreferrer">Chess.com Published Data API</a> ¬∑ Backend: Firebase Firestore
    </footer>
  </main>

  <script type="module">
    // === Firebase Setup ===
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js';
    import {
      getFirestore,
      doc,
      getDoc,
      setDoc,
      updateDoc,
      serverTimestamp
    } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js';

    // TODO: Hier deine Firebase-Konfiguration aus der Firebase Console einf√ºgen
    const firebaseConfig = {
  apiKey: "AIzaSyBtEkLjoW0pEqxOodau5dAArMkkf1hgjnc",
  authDomain: "chess-rewards.firebaseapp.com",
  projectId: "chess-rewards",
  storageBucket: "chess-rewards.firebasestorage.app",
  messagingSenderId: "118996095284",
  appId: "1:118996095284:web:0a80d27fe93668563cd561"
};

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // === Konfiguration ===
    const PLAYERS = ["ERR_Daemon", "M41K", "Kathi_2905"];
    const CHEF_USERNAME = "M41K"; // du, bekommst keine Rewards angezeigt

    const MODES = [
      { key: "chess_rapid", label: "Rapid",  icon: "‚è±Ô∏è" },
      { key: "chess_blitz", label: "Blitz",  icon: "‚ö°" },
      { key: "chess_bullet",label: "Bullet", icon: "üí£" },
      { key: "chess_daily", label: "Daily",  icon: "üì¨" },
    ];

    const RAPID_MILESTONES = [
      { rating: 500,  reward:  50 },
      { rating: 1000, reward: 100 },
      { rating: 1500, reward: 150 },
      { rating: 2000, reward: 200 }
    ];

    const REWARD_COLLECTION = "rewardProgress";

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error("HTTP " + res.status + " for " + url);
      return res.json();
    }

    // === Chess.com Stats laden ===
    async function loadChessStats(username) {
      const uname = username.toLowerCase();
      const [profile, stats] = await Promise.allSettled([
        fetchJson(`https://api.chess.com/pub/player/${uname}`),
        fetchJson(`https://api.chess.com/pub/player/${uname}/stats`)
      ]);

      const profileData = profile.status === "fulfilled" ? profile.value : {};
      const statsData   = stats.status === "fulfilled"   ? stats.value   : {};

      const modes = MODES.map(m => extractMode(statsData, m.key, m.label, m.icon))
        .filter(Boolean);

      const tactics = extractTactics(statsData);

      const totalGames = modes.reduce((sum, m) => sum + m.games, 0);
      const active = totalGames > 0;

      const tacticsRating = tactics?.current ?? null;
      const rapidMode = modes.find(m => m.key === "chess_rapid");
      const rapidRating = rapidMode?.current ?? null;

      return {
        username,
        avatar: profileData.avatar || null,
        url: profileData.url || null,
        modes,
        tactics,
        totalGames,
        active,
        tacticsRating,
        rapidRating
      };
    }

    function extractMode(stats, key, label, icon) {
      const s = stats[key];
      if (!s || !s.last || !s.record) return null;

      const current = s.last.rating ?? null;
      const best    = s.best && s.best.rating != null ? s.best.rating : null;
      const rec     = s.record || {};
      const wins  = rec.win   || 0;
      const loss  = rec.loss  || 0;
      const draw  = rec.draw  || 0;
      const games = wins + loss + draw;
      const winrate = games ? Math.round((wins / games) * 100) : null;
      const gap = (best != null && current != null) ? best - current : null;

      return {
        key,
        label,
        icon,
        current,
        best,
        wins,
        loss,
        draw,
        games,
        winrate,
        gap
      };
    }

    function extractTactics(stats) {
      const t = stats.tactics;
      if (!t) return null;
      const last    = t.last || {};
      const highest = t.highest || {};
      const lowest  = t.lowest || {};
      const current = last.rating ?? highest.rating ?? null;
      return {
        current,
        highest: highest.rating ?? null,
        lowest: lowest.rating ?? null
      };
    }

    // === Firestore Reward-Dokument ===
    async function loadRewardDoc(username, tacticsRating, rapidRating) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      const snap = await getDoc(ref);

      if (!snap.exists()) {
        // Baseline = aktuelles Rating zum ersten Zeitpunkt
        const baselineTactics = tacticsRating ?? 0;
        const baselineRapid   = rapidRating ?? 0;
        const initData = {
          baselineTactics,
          baselineRapid,
          tacticsStepsClaimed: 0,
          rapidStepsClaimed: 0,
          rapidMilestonesClaimed: [],
          pendingClaim: null,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        };
        await setDoc(ref, initData);
        return initData;
      }

      return snap.data();
    }

    // === Rewards berechnen ===
    function computeRewardState(username, tacticsRating, rapidRating, rewardDoc) {
      const isChef = username === CHEF_USERNAME;

      const baselineT = rewardDoc.baselineTactics ?? 0;
      const baselineR = rewardDoc.baselineRapid   ?? 0;

      const tNow = tacticsRating ?? 0;
      const rNow = rapidRating   ?? 0;

      // Taktik: 10 ‚Ç¨ pro +100 Elo √ºber Baseline
      const deltaT = Math.max(0, tNow - baselineT);
      const tacticsStepsTotal = Math.floor(deltaT / 100);
      const tacticsRewardRaw  = tacticsStepsTotal * 10;

      const tacticsStepsClaimed = rewardDoc.tacticsStepsClaimed ?? 0;
      const tacticsStepsPaid    = Math.min(tacticsStepsClaimed, tacticsStepsTotal);
      const tacticsStepsNew     = Math.max(0, tacticsStepsTotal - tacticsStepsPaid);
      const tacticsPaid         = tacticsStepsPaid * 10;
      const tacticsUnpaid       = tacticsStepsNew  * 10;

      const nextTacticsTarget = baselineT + (tacticsStepsTotal + 1) * 100;
      const tacticsToNext     = Math.max(0, nextTacticsTarget - tNow);

      // Rapid: 10 ‚Ç¨ pro +100 Elo √ºber Baseline + Meilensteine
      const deltaR = Math.max(0, rNow - baselineR);
      const rapidStepsTotal = Math.floor(deltaR / 100);
      const rapidStepsRewardRaw = rapidStepsTotal * 10;

      const rapidStepsClaimed = rewardDoc.rapidStepsClaimed ?? 0;
      const rapidStepsPaid    = Math.min(rapidStepsClaimed, rapidStepsTotal);
      const rapidStepsNew     = Math.max(0, rapidStepsTotal - rapidStepsPaid);
      const rapidStepsPaidEuro   = rapidStepsPaid * 10;
      const rapidStepsUnpaidEuro = rapidStepsNew * 10;

      const claimedMilestones = rewardDoc.rapidMilestonesClaimed ?? [];
      const reachedMilestones = RAPID_MILESTONES.filter(m =>
        m.rating > baselineR && m.rating <= rNow
      );
      const reachedRatings = reachedMilestones.map(m => m.rating);
      const newMilestones = reachedMilestones.filter(m => !claimedMilestones.includes(m.rating));
      const milestoneRewardRaw = reachedMilestones.reduce((sum, m) => sum + m.reward, 0);
      const milestonePaid = reachedMilestones
        .filter(m => claimedMilestones.includes(m.rating))
        .reduce((sum, m) => sum + m.reward, 0);
      const milestoneUnpaid = milestoneRewardRaw - milestonePaid;

      const rapidRewardRaw = rapidStepsRewardRaw + milestoneRewardRaw;
      const rapidPaid      = rapidStepsPaidEuro + milestonePaid;
      const rapidUnpaid    = rapidStepsUnpaidEuro + milestoneUnpaid;

      const totalRaw    = tacticsRewardRaw + rapidRewardRaw;
      const totalPaid   = tacticsPaid + rapidPaid;
      const totalUnpaid = totalRaw - totalPaid;

      const pending = rewardDoc.pendingClaim || null;

      const claimable = {
        tacticsStepsToClaim: tacticsStepsNew,
        rapidStepsToClaim: rapidStepsNew,
        rapidMilestonesToClaim: newMilestones.map(m => m.rating),
        amount: totalUnpaid
      };

      return {
        isChef,
        baselineT,
        baselineR,
        tactics: {
          now: tNow,
          delta: deltaT,
          stepsTotal: tacticsStepsTotal,
          rewardRaw: tacticsRewardRaw,
          paid: tacticsPaid,
          unpaid: tacticsUnpaid,
          toNext: tacticsToNext
        },
        rapid: {
          now: rNow,
          delta: deltaR,
          stepsTotal: rapidStepsTotal,
          stepsRewardRaw: rapidStepsRewardRaw,
          stepsPaidEuro: rapidStepsPaidEuro,
          stepsUnpaidEuro: rapidStepsUnpaidEuro,
          reachedMilestones,
          claimedMilestones,
          newMilestones,
          milestoneRewardRaw,
          milestonePaid,
          milestoneUnpaid,
          rewardRaw: rapidRewardRaw,
          paid: rapidPaid,
          unpaid: rapidUnpaid
        },
        total: {
          raw: totalRaw,
          paid: totalPaid,
          unpaid: totalUnpaid
        },
        claimable,
        pending
      };
    }

    // Claim anlegen (Status: requested)
    async function createClaim(username, rewardState) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);

      const { claimable } = rewardState;
      if (claimable.amount <= 0) return;

      const pendingClaim = {
        status: "requested",
        amount: claimable.amount,
        tacticsStepsToClaim: claimable.tacticsStepsToClaim,
        rapidStepsToClaim: claimable.rapidStepsToClaim,
        rapidMilestonesToClaim: claimable.rapidMilestonesToClaim,
        createdAt: serverTimestamp()
      };

      await updateDoc(ref, {
        pendingClaim,
        updatedAt: serverTimestamp()
      });
    }

    // Claim als bezahlt markieren (Schritte & Milestones werden "verbraucht")
    async function markClaimPaid(username, rewardState) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      const pending = rewardState.pending;
      if (!pending || pending.status !== "requested") return;

      const snap = await getDoc(ref);
      if (!snap.exists()) return;
      const data = snap.data();

      const currentTacticsStepsClaimed = data.tacticsStepsClaimed ?? 0;
      const currentRapidStepsClaimed   = data.rapidStepsClaimed ?? 0;
      const currentRapidMilestonesClaimed = data.rapidMilestonesClaimed ?? [];

      const newTacticsStepsClaimed =
        currentTacticsStepsClaimed + (pending.tacticsStepsToClaim || 0);
      const newRapidStepsClaimed =
        currentRapidStepsClaimed + (pending.rapidStepsToClaim || 0);

      const newMilestonesClaimed = Array.from(
        new Set([
          ...currentRapidMilestonesClaimed,
          ...(pending.rapidMilestonesToClaim || [])
        ])
      );

      await updateDoc(ref, {
        tacticsStepsClaimed: newTacticsStepsClaimed,
        rapidStepsClaimed: newRapidStepsClaimed,
        rapidMilestonesClaimed: newMilestonesClaimed,
        pendingClaim: {
          ...pending,
          status: "paid",
          resolvedAt: serverTimestamp()
        },
        updatedAt: serverTimestamp()
      });
    }

    async function resetPendingClaim(username) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      await updateDoc(ref, {
        pendingClaim: null,
        updatedAt: serverTimestamp()
      });
    }

    // === Achievements & Fokus (einfach) ===
    function buildAchievements(stats, rewardState) {
      const { totalGames, modes, tactics } = stats;
      const { total } = rewardState;
      const ach = [];

      if (totalGames === 0) {
        ach.push({ label: "üò¥ AFK", style: "fail", title: "Noch keine Partien ‚Äì perfekte Gelegenheit f√ºr ein Comeback." });
      } else if (totalGames >= 200) {
        ach.push({ label: "üß± Iron Grinder", style: "gold", title: `${totalGames} Gesamtpartien.` });
      } else if (totalGames >= 100) {
        ach.push({ label: "üèÉ Grinder", style: "silver", title: `${totalGames} Gesamtpartien.` });
      } else if (totalGames >= 50) {
        ach.push({ label: "üéØ Warmgelaufen", style: "bronze", title: `${totalGames} Gesamtpartien.` });
      }

      const modesWithGames = modes.filter(m => m.games >= 20 && m.winrate != null);
      if (modesWithGames.length) {
        modesWithGames.sort((a, b) => b.winrate - a.winrate);
        const best = modesWithGames[0];
        if (best.winrate >= 60) {
          ach.push({
            label: `üî• ${best.label}-Boss`,
            style: "gold",
            title: `Winrate ${best.winrate}% in ${best.label}.`
          });
        }
      }

      if (total.raw >= 50) {
        ach.push({
          label: "üí∂ Reward Hunter",
          style: "silver",
          title: `Schon ${total.raw} ‚Ç¨ an m√∂glichen Belohnungen freigespielt.`
        });
      }

      if (tactics && tactics.current != null && tactics.current >= 2200) {
        ach.push({
          label: "üß† Tactics Monster",
          style: "gold",
          title: `Taktikwertung ${tactics.current}.`
        });
      }

      return ach.slice(0, 3);
    }

    function buildFocus(stats, rewardState) {
      const { modes, tactics } = stats;
      const { rapid, tactics: tState } = rewardState;

      if (rapid.unpaid > 0) {
        return {
          title: "Rapid pushen",
          text: `Du hast noch <strong>${rapid.unpaid} ‚Ç¨</strong> Rapid-Belohnungen offen. Spiel ein paar konzentrierte Rapid-Partien.`
        };
      }

      if (tState.unpaid > 0) {
        return {
          title: "Taktikblock",
          text: `Mit ein paar Taktik-Sessions kannst du weitere <strong>${tState.unpaid} ‚Ç¨</strong> freischalten.`
        };
      }

      if (tactics && tactics.current != null) {
        return {
          title: "Mini-Taktikblock",
          text: `Mach zuerst 10‚Äì15 Taktikaufgaben um deine aktuelle Wertung (${tactics.current}) herum, dann ab an die Bretter.`
        };
      }

      return {
        title: "Einfach spielen",
        text: "Such dir ein Zeitformat, das dir Spa√ü macht, und spiel ein paar ruhige, konzentrierte Partien."
      };
    }

    // === Rendering ===
    function renderPlayerCard(stats, rewardState) {
      const cards = document.getElementById("cards");
      const card = document.createElement("article");
      card.className = "card";

      const header = document.createElement("div");
      header.className = "card-header";

      const left = document.createElement("div");
      left.className = "card-title-block";

      if (stats.avatar) {
        const img = document.createElement("img");
        img.src = stats.avatar;
        img.alt = stats.username;
        img.className = "avatar";
        left.appendChild(img);
      }

      const nameEl = document.createElement("div");
      nameEl.className = "username";
      nameEl.textContent = stats.username; // kein (Chef) mehr
      left.appendChild(nameEl);

      header.appendChild(left);

      const status = document.createElement("div");
      status.className = "status-badge " + (stats.active ? "status-active" : "status-chill");
      status.textContent = stats.active ? "AKTIV" : "PAUSE";
      header.appendChild(status);

      card.appendChild(header);

      // Ratings & PBs
      const modesTitle = document.createElement("div");
      modesTitle.className = "section-title";
      modesTitle.textContent = "Ratings & Bestleistungen";
      card.appendChild(modesTitle);

      const modesWrap = document.createElement("div");
      modesWrap.className = "modes";

      if (!stats.modes.length) {
        const p = document.createElement("div");
        p.style.fontSize = "0.78rem";
        p.style.color = "#9ca3af";
        p.textContent = "Keine Partiedaten verf√ºgbar.";
        modesWrap.appendChild(p);
      } else {
        stats.modes.forEach(m => {
          const row = document.createElement("div");
          row.className = "mode-row";

          const leftCol = document.createElement("div");
          leftCol.className = "mode-left";

          const label = document.createElement("div");
          label.className = "mode-label";
          label.innerHTML = `${m.icon} ${m.label}`;
          leftCol.appendChild(label);

          const meta = document.createElement("div");
          meta.className = "mode-meta";
          const winrateText = m.winrate != null ? `${m.winrate}%` : "‚Äì";
          meta.textContent = `${m.games} Partien ¬∑ Winrate ${winrateText}`;
          leftCol.appendChild(meta);

          const rightCol = document.createElement("div");
          rightCol.className = "mode-right";

          const current = document.createElement("div");
          current.innerHTML = `<span class="rating">${m.current ?? "‚Äì"}</span>`;
          rightCol.appendChild(current);

          const gapText = document.createElement("div");
          if (m.best != null && m.current != null) {
            const gap = m.best - m.current;
            let cls = "gap-mid";
            let labelText = "";
            if (gap <= 0) {
              cls = "gap-good";
              labelText = "Neue PB!";
            } else if (gap <= 20) {
              cls = "gap-good";
              labelText = `${gap} bis PB`;
            } else if (gap <= 80) {
              cls = "gap-mid";
              labelText = `${gap} bis PB`;
            } else {
              cls = "gap-bad";
              labelText = `${gap} unter PB`;
            }
            gapText.innerHTML = `<span class="${cls}">${labelText}</span>`;
          } else {
            gapText.textContent = "‚Äî";
          }
          rightCol.appendChild(gapText);

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          modesWrap.appendChild(row);
        });
      }

      card.appendChild(modesWrap);

      // Badges
      const achTitle = document.createElement("div");
      achTitle.className = "section-title";
      achTitle.textContent = "Badges";
      card.appendChild(achTitle);

      const achRow = document.createElement("div");
      achRow.className = "badge-row";
      const achievements = buildAchievements(stats, rewardState);

      if (!achievements.length) {
        const span = document.createElement("span");
        span.style.color = "#9ca3af";
        span.style.fontSize = "0.75rem";
        span.textContent = "Spiel ein bisschen mehr, um Badges freizuschalten.";
        achRow.appendChild(span);
      } else {
        achievements.forEach(a => {
          const span = document.createElement("span");
          span.className = `badge ${a.style}`;
          span.textContent = a.label;
          if (a.title) span.title = a.title;
          achRow.appendChild(span);
        });
      }
      card.appendChild(achRow);

      // Fokus
      const focusTitle = document.createElement("div");
      focusTitle.className = "section-title";
      focusTitle.textContent = "Heutiger Fokus";
      card.appendChild(focusTitle);

      const focusInfo = buildFocus(stats, rewardState);
      const focus = document.createElement("div");
      focus.className = "focus";
      focus.innerHTML = `<strong>${focusInfo.title}</strong><br>${focusInfo.text}`;
      card.appendChild(focus);

      // Belohnungen & Progression ‚Äì NICHT f√ºr M41K
      if (!rewardState.isChef) {
        const rewardTitle = document.createElement("div");
        rewardTitle.className = "section-title";
        rewardTitle.textContent = "Belohnungen & Progression";
        card.appendChild(rewardTitle);

        const rewardBox = document.createElement("div");
        rewardBox.className = "focus";

        const { tactics, rapid, total, pending, claimable } = rewardState;
        const activePending = pending && pending.status === "requested" ? pending : null;

        rewardBox.innerHTML = `
          <div class="reward-row">
            <span class="reward-label">Gesamt erspielt (theoretisch):</span>
            <span class="reward-value">${total.raw} ‚Ç¨</span>
            <span class="reward-label">Bereits ausgezahlt:</span>
            <span class="reward-value">${total.paid} ‚Ç¨</span>
            <span class="reward-label">Noch offen:</span>
            <span class="reward-value">${total.unpaid} ‚Ç¨</span>
          </div>
          <hr style="border:none;border-top:1px solid #1f2937;margin:0.5rem 0;">
          <div class="reward-row">
            <span class="reward-label">Taktik (√ºber ${rewardState.baselineT}):</span>
            <span class="reward-value">${tactics.rewardRaw} ‚Ç¨</span>
            <span class="reward-label">Rapid (√ºber ${rewardState.baselineR}):</span>
            <span class="reward-value">${rapid.rewardRaw} ‚Ç¨</span>
          </div>
        `;

        // Status-Chip
        const chip = document.createElement("div");
        let chipClass, chipText;
        if (activePending) {
          chipClass = "chip-requested";
          chipText = `Anfrage offen: ${activePending.amount} ‚Ç¨ ‚Äì wartet darauf, als ausgezahlt markiert zu werden.`;
        } else if (total.unpaid > 0) {
          chipClass = "chip-open";
          chipText = `Noch nicht angefordert: ${total.unpaid} ‚Ç¨.`;
        } else {
          chipClass = "chip-paid";
          chipText = "Alle erreichbaren Belohnungen sind aktuell als ausgezahlt markiert.";
        }
        chip.className = `reward-chip ${chipClass}`;
        chip.textContent = chipText;
        rewardBox.appendChild(chip);

        // Buttons ‚Äì jeder darf klicken, Vertrauenbasis
        if (!activePending && total.unpaid > 0) {
          const btn = document.createElement("button");
          btn.className = "btn";
          btn.textContent = `Belohnung einfordern (${total.unpaid} ‚Ç¨)`;
          btn.addEventListener("click", async () => {
            btn.disabled = true;
            await createClaim(stats.username, rewardState);
            location.reload();
          });
          rewardBox.appendChild(btn);
        } else if (activePending) {
          const btnPaid = document.createElement("button");
          btnPaid.className = "btn";
          btnPaid.textContent = `Ausgezahlt (${activePending.amount} ‚Ç¨)`;
          btnPaid.addEventListener("click", async () => {
            btnPaid.disabled = true;
            await markClaimPaid(stats.username, rewardState);
            location.reload();
          });
          rewardBox.appendChild(btnPaid);

          const btnCancel = document.createElement("button");
          btnCancel.className = "btn btn-danger";
          btnCancel.textContent = "Anfrage zur√ºcksetzen";
          btnCancel.addEventListener("click", async () => {
            btnCancel.disabled = true;
            await resetPendingClaim(stats.username);
            location.reload();
          });
          rewardBox.appendChild(btnCancel);
        }

        card.appendChild(rewardBox);
      }

      cards.appendChild(card);
    }

    function renderSquad(players) {
      const container = document.getElementById("squad");
      container.innerHTML = "";

      const card = document.createElement("div");
      card.className = "squad-card";

      const title = document.createElement("div");
      title.className = "squad-title";
      title.innerHTML = "üí¨ Squad-√úbersicht";
      card.appendChild(title);

      const list = document.createElement("div");
      list.className = "squad-list";

      const allModes = [];
      players.forEach(p => p.stats.modes.forEach(m => allModes.push({ player: p.stats.username, ...m })));
      const rapid = allModes.filter(m => m.key === "chess_rapid" && m.current != null);
      if (rapid.length) {
        rapid.sort((a, b) => b.current - a.current);
        const r = rapid[0];
        list.innerHTML += `<div>üèÜ H√∂chstes Rapid-Rating: <strong>${r.player}</strong> (${r.current}).</div>`;
      }

      const activeCount = players.filter(p => p.stats.active).length;
      list.innerHTML += `<div>üìÜ Aktuell aktiv: <strong>${activeCount}/${players.length}</strong>.</div>`;

      card.appendChild(list);
      container.appendChild(card);
    }

    // === Init ===
    async function init() {
      const subtitle = document.getElementById("subtitle");
      subtitle.textContent = "Lade Daten von Chess.com & Firestore‚Ä¶";

      const playersCombined = [];

      for (const name of PLAYERS) {
        try {
          const stats = await loadChessStats(name);
          const rewardDoc = await loadRewardDoc(name, stats.tacticsRating, stats.rapidRating);
          const rewardState = computeRewardState(name, stats.tacticsRating, stats.rapidRating, rewardDoc);

          playersCombined.push({ stats, rewardState });
          renderPlayerCard(stats, rewardState);
        } catch (e) {
          console.error("Fehler bei Spieler", name, e);
        }
      }

      renderSquad(playersCombined);

      const now = new Date();
      subtitle.textContent = `Live-Stand ¬∑ aktualisiert am ${now.toLocaleString()}`;
    }

    init();
  </script>
</body>
</html>