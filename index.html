<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Chess Squad ‚Äì Rewards & Activity</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #000 100%);
      color: #e5e7eb;
    }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 2rem 1.25rem 3rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    main {
      width: 100%;
      max-width: 1100px;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(2rem, 3vw, 2.5rem);
      text-align: center;
    }

    .subtitle {
      color: #9ca3af;
      font-size: 0.85rem;
      text-align: center;
      margin-top: 0.4rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.2rem;
      width: 100%;
    }

    .card {
      background: radial-gradient(circle at top, #111827, #020617);
      border-radius: 0.9rem;
      padding: 1rem 1.1rem 1.1rem;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 45px rgba(0,0,0,0.6);
      font-size: 0.8rem;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 0.4rem;
    }

    .card-title-block {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .avatar {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 2px solid #22c55e;
      object-fit: cover;
      background: #020617;
      flex-shrink: 0;
    }

    .username {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .status-badge {
      padding: 0.15rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .status-active {
      background: #065f46;
      color: #bbf7d0;
    }

    .status-chill {
      background: #7f1d1d;
      color: #fecaca;
    }

    .section-title {
      margin-top: 0.55rem;
      font-size: 0.78rem;
      font-weight: 600;
      color: #d1d5db;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .modes {
      margin-top: 0.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.76rem;
    }

    .mode-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.25rem 0.4rem;
      border-radius: 0.5rem;
      background: rgba(15,23,42,0.7);
    }

    .mode-left {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }

    .mode-label {
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .mode-meta {
      color: #9ca3af;
      font-size: 0.7rem;
    }

    .mode-right {
      text-align: right;
      font-size: 0.74rem;
    }

    .rating {
      font-weight: 600;
      color: #facc15;
    }

    .gap-good {
      color: #22c55e;
    }
    .gap-mid {
      color: #eab308;
    }
    .gap-bad {
      color: #f97316;
    }

    .badge-row {
      margin-top: 0.3rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      font-size: 0.7rem;
    }

    .badge {
      padding: 0.15rem 0.45rem;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      white-space: nowrap;
      cursor: default;
    }

    .badge.gold {
      border-color: #fbbf24;
      color: #facc15;
    }

    .badge.silver {
      border-color: #9ca3af;
      color: #e5e7eb;
    }

    .badge.bronze {
      border-color: #f97316;
      color: #fed7aa;
    }

    .badge.fail {
      border-color: #ef4444;
      color: #fecaca;
    }

    .focus {
      margin-top: 0.4rem;
      font-size: 0.76rem;
      line-height: 1.3;
      padding: 0.4rem 0.45rem;
      border-radius: 0.55rem;
      background: rgba(15,23,42,0.85);
      border: 1px dashed #1f2937;
      color: #e5e7eb;
    }

    .focus strong {
      color: #a5b4fc;
    }

    .reward-row {
      margin-top: 0.35rem;
      font-size: 0.76rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      row-gap: 0.1rem;
      column-gap: 0.4rem;
    }

    .reward-label {
      color: #9ca3af;
    }

    .reward-value {
      text-align: right;
      font-weight: 600;
    }

    .reward-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.12rem 0.5rem;
      border-radius: 999px;
      font-size: 0.7rem;
      margin-top: 0.3rem;
    }

    .chip-open {
      background: rgba(234,179,8,0.15);
      border: 1px solid #eab308;
      color: #fde68a;
    }

    .chip-requested {
      background: rgba(59,130,246,0.15);
      border: 1px solid #3b82f6;
      color: #bfdbfe;
    }

    .chip-paid {
      background: rgba(34,197,94,0.15);
      border: 1px solid #22c55e;
      color: #bbf7d0;
    }

    .btn {
      margin-top: 0.4rem;
      padding: 0.25rem 0.7rem;
      border-radius: 999px;
      border: 1px solid #22c55e;
      background: #022c22;
      color: #bbf7d0;
      font-size: 0.72rem;
      cursor: pointer;
    }
    .btn:hover {
      filter: brightness(1.07);
    }

    .btn-danger {
      border-color: #ef4444;
      background: #450a0a;
      color: #fecaca;
      margin-left: 0.3rem;
    }

    .weekly-goals {
      margin-top: 0.3rem;
      font-size: 0.74rem;
      display: flex;
      flex-direction: column;
      gap: 0.18rem;
    }

    .weekly-goal-row {
      display: flex;
      justify-content: space-between;
      gap: 0.4rem;
      padding: 0.18rem 0.3rem;
      border-radius: 0.45rem;
      background: rgba(15,23,42,0.6);
    }

    .weekly-goal-name {
      font-weight: 500;
    }

    .weekly-goal-status {
      font-size: 0.72rem;
      text-align: right;
    }

    .status-ok {
      color: #bbf7d0;
    }

    .status-paid {
      color: #93c5fd;
    }

    .status-missing {
      color: #facc15;
    }

    .squad-card {
      background: #020617;
      border-radius: 0.9rem;
      border: 1px solid #1f2937;
      padding: 0.8rem 1rem;
      font-size: 0.78rem;
    }

    .squad-title {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 0.3rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .squad-list {
      font-size: 0.78rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    footer {
      font-size: 0.72rem;
      color: #6b7280;
      text-align: center;
      margin-top: 1.2rem;
    }

    a {
      color: #60a5fa;
    }

    /* Elo-Step-Ansicht */
    .step-sections {
      margin-top: 0.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .step-section {
      font-size: 0.74rem;
    }

    .step-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.18rem;
    }

    .step-label {
      font-weight: 600;
      color: #e5e7eb;
    }

    .step-current {
      font-weight: 600;
      color: #facc15;
    }

    .step-summary {
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .step-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      margin-top: 0.15rem;
    }

    .step-item {
      min-width: 46px;
      padding: 0.15rem 0.3rem;
      border-radius: 999px;
      font-size: 0.7rem;
      text-align: center;
      border: 1px solid;
      box-sizing: border-box;
    }

    .step-item span {
      display: inline-block;
    }

    .step-paid {
      background: rgba(34,197,94,0.18);
      border-color: #22c55e;
      color: #bbf7d0;
    }

    .step-open {
      background: rgba(59,130,246,0.18);
      border-color: #3b82f6;
      color: #bfdbfe;
    }

    .step-locked {
      background: rgba(15,23,42,0.9);
      border-color: #1f2937;
      color: #6b7280;
    }
  </style>
</head>
<body>
  <main>
    <header style="text-align:center;">
      <h1>‚ôüÔ∏è Chess Squad Rewards</h1>
      <p class="subtitle" id="subtitle">
        Lade Live-Daten von Chess.com‚Ä¶
      </p>
    </header>

    <section class="grid" id="cards"></section>
    <section id="squad"></section>

    <footer>
      Datenquelle: <a href="https://www.chess.com/news/view/published-data-api" target="_blank" rel="noreferrer">Chess.com API</a> ¬∑ Backend: Firebase
    </footer>
  </main>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js';
    import {
      getFirestore,
      doc,
      getDoc,
      setDoc,
      updateDoc,
      serverTimestamp
    } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBtEkLjoW0pEqxOodau5dAArMkkf1hgjnc",
      authDomain: "chess-rewards.firebaseapp.com",
      projectId: "chess-rewards",
      storageBucket: "chess-rewards.firebasestorage.app",
      messagingSenderId: "118996095284",
      appId: "1:118996095284:web:0a80d27fe93668563cd561"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const PLAYERS = ["ERR_Daemon", "M41K", "Kathi_2905"];
    const CHEF_USERNAME = "M41K";

    const MODES = [
      { key: "chess_rapid", label: "Rapid",  icon: "‚è±Ô∏è" },
      { key: "chess_blitz", label: "Blitz",  icon: "‚ö°" },
      { key: "chess_bullet",label: "Bullet", icon: "üí£" },
      { key: "chess_daily", label: "Daily",  icon: "üì¨" },
    ];

    const RAPID_MILESTONES = [
      { rating: 500,  reward:  50 },
      { rating: 1000, reward: 100 },
      { rating: 1500, reward: 150 },
      { rating: 2000, reward: 200 }
    ];

    const REWARD_COLLECTION = "rewardProgress";

    const WEEKLY_COLLECTION = "weeklyActivity";
    const WEEKLY_CAP = 10;

    const WEEKLY_GOALS = [
      { id: "rapid10",  label: "10 Rapid-Games", amount: 3 },
      { id: "games20",  label: "20 Games gesamt", amount: 3 },
      { id: "days5",    label: "5 aktive Tage", amount: 3 },
      { id: "days7",    label: "7/7 Tage aktiv", amount: 5 },
      { id: "noTimeouts", label: "Kein Timeout", amount: 2 }
    ];

    const STEP_VIEW_COUNT = 15; // wie viele 100-Elo-Steps pro Modus anzeigen

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error("HTTP " + res.status + " for " + url);
      return res.json();
    }

    async function loadChessStats(username) {
      const uname = username.toLowerCase();
      const [profile, stats] = await Promise.allSettled([
        fetchJson(`https://api.chess.com/pub/player/${uname}`),
        fetchJson(`https://api.chess.com/pub/player/${uname}/stats`)
      ]);

      const profileData = profile.status === "fulfilled" ? profile.value : {};
      const statsData   = stats.status === "fulfilled"   ? stats.value   : {};

      const modes = MODES.map(m => extractMode(statsData, m.key, m.label, m.icon))
        .filter(Boolean);

      const tactics = extractTactics(statsData);

      const totalGames = modes.reduce((sum, m) => sum + m.games, 0);
      const active = totalGames > 0;

      const tacticsRating = tactics?.current ?? null;
      const rapidMode = modes.find(m => m.key === "chess_rapid");
      const rapidRating = rapidMode?.current ?? null;

      return {
        username,
        avatar: profileData.avatar || null,
        url: profileData.url || null,
        modes,
        tactics,
        totalGames,
        active,
        tacticsRating,
        rapidRating
      };
    }

    function extractMode(stats, key, label, icon) {
      const s = stats[key];
      if (!s || !s.last || !s.record) return null;

      const current = s.last.rating ?? null;
      const best    = s.best && s.best.rating != null ? s.best.rating : null;
      const rec     = s.record || {};
      const wins  = rec.win   || 0;
      const loss  = rec.loss  || 0;
      const draw  = rec.draw  || 0;
      const games = wins + loss + draw;
      const winrate = games ? Math.round((wins / games) * 100) : null;
      const gap = (best != null && current != null) ? best - current : null;

      return {
        key,
        label,
        icon,
        current,
        best,
        wins,
        loss,
        draw,
        games,
        winrate,
        gap
      };
    }

    function extractTactics(stats) {
      const t = stats.tactics;
      if (!t) return null;
      const last    = t.last || {};
      const highest = t.highest || {};
      const current = last.rating ?? highest.rating ?? null;
      return {
        current,
        highest: highest.rating ?? null
      };
    }

    async function loadRewardDoc(username, tacticsRating, rapidRating) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      const snap = await getDoc(ref);

      if (!snap.exists()) {
        const baselineTactics = tacticsRating ?? 0;
        const baselineRapid   = rapidRating ?? 0;
        const initData = {
          baselineTactics,
          baselineRapid,
          tacticsStepsClaimed: 0,
          rapidStepsClaimed: 0,
          rapidMilestonesClaimed: [],
          pendingClaim: null,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        };
        await setDoc(ref, initData);
        return initData;
      }

      return snap.data();
    }

    function buildStepDetails(baseline, current, stepsClaimed, maxSteps = STEP_VIEW_COUNT) {
      const steps = [];
      for (let i = 1; i <= maxSteps; i++) {
        const rating = baseline + i * 100;
        let status = "locked"; // noch nicht erreicht

        if (current >= rating) {
          if (i <= stepsClaimed) {
            status = "paid";   // erreicht & bezahlt
          } else {
            status = "open";   // erreicht, aber noch offen
          }
        }

        steps.push({
          index: i,
          rating,
          status
        });
      }
      return steps;
    }

    function computeRewardState(username, tacticsRating, rapidRating, rewardDoc) {
      const isChef = username === CHEF_USERNAME;
      const baselineT = rewardDoc.baselineTactics ?? 0;
      const baselineR = rewardDoc.baselineRapid   ?? 0;

      const tNow = tacticsRating ?? 0;
      const rNow = rapidRating   ?? 0;

      // --- Taktik-Delta & Steps ---
      const deltaT = Math.max(0, tNow - baselineT);
      const tacticsStepsTotal = Math.floor(deltaT / 100);
      const tacticsRewardRaw  = tacticsStepsTotal * 10;

      const tacticsStepsClaimed = rewardDoc.tacticsStepsClaimed ?? 0;
      const tacticsStepsPaid    = Math.min(tacticsStepsClaimed, tacticsStepsTotal);
      const tacticsStepsNew     = Math.max(0, tacticsStepsTotal - tacticsStepsPaid);
      const tacticsPaid         = tacticsStepsPaid * 10;
      const tacticsUnpaid       = tacticsStepsNew  * 10;

      const nextTacticsTarget = baselineT + (tacticsStepsTotal + 1) * 100;
      const tacticsToNext     = Math.max(0, nextTacticsTarget - tNow);

      // --- Rapid-Delta & Steps ---
      const deltaR = Math.max(0, rNow - baselineR);
      const rapidStepsTotal = Math.floor(deltaR / 100);
      const rapidStepsRewardRaw = rapidStepsTotal * 10;

      const rapidStepsClaimed = rewardDoc.rapidStepsClaimed ?? 0;
      const rapidStepsPaid    = Math.min(rapidStepsClaimed, rapidStepsTotal);
      const rapidStepsNew     = Math.max(0, rapidStepsTotal - rapidStepsPaid);
      const rapidStepsPaidEuro   = rapidStepsPaid * 10;
      const rapidStepsUnpaidEuro = rapidStepsNew * 10;

      // --- Step-Details (f√ºr UI) ---
      const tacticsStepDetails = buildStepDetails(baselineT, tNow, tacticsStepsClaimed);
      const rapidStepDetails   = buildStepDetails(baselineR, rNow, rapidStepsClaimed);

      const eloSteps = {
        tactics: {
          current: tNow,
          baseline: baselineT,
          total: tacticsStepsTotal,
          paid: tacticsStepsPaid,
          open: tacticsStepsNew,
          details: tacticsStepDetails
        },
        rapid: {
          current: rNow,
          baseline: baselineR,
          total: rapidStepsTotal,
          paid: rapidStepsPaid,
          open: rapidStepsNew,
          details: rapidStepDetails
        }
      };

      // --- Rapid-Meilensteine ---
      const claimedMilestones = rewardDoc.rapidMilestonesClaimed ?? [];

      const reachedMilestones = RAPID_MILESTONES.filter(m =>
        m.rating > baselineR && m.rating <= rNow
      );

      const milestoneDetails = RAPID_MILESTONES.map(m => {
        const reached = m.rating > baselineR && m.rating <= rNow;
        const paid = reached && claimedMilestones.includes(m.rating);
        return {
          rating: m.rating,
          reward: m.reward,
          reached,
          paid
        };
      });

      const newMilestones = reachedMilestones.filter(m => !claimedMilestones.includes(m.rating));
      const milestoneRewardRaw = reachedMilestones.reduce((sum, m) => sum + m.reward, 0);
      const milestonePaid = reachedMilestones
        .filter(m => claimedMilestones.includes(m.rating))
        .reduce((sum, m) => sum + m.reward, 0);
      const milestoneUnpaid = milestoneRewardRaw - milestonePaid;

      // --- Rapid gesamt (Steps + Meilensteine) ---
      const rapidRewardRaw = rapidStepsRewardRaw + milestoneRewardRaw;
      const rapidPaid      = rapidStepsPaidEuro + milestonePaid;
      const rapidUnpaid    = rapidStepsUnpaidEuro + milestoneUnpaid;

      // --- Total ---
      const totalRaw    = tacticsRewardRaw + rapidRewardRaw;
      const totalPaid   = tacticsPaid + rapidPaid;
      const totalUnpaid = totalRaw - totalPaid;

      const pending = rewardDoc.pendingClaim || null;

      const claimable = {
        tacticsStepsToClaim: tacticsStepsNew,
        rapidStepsToClaim: rapidStepsNew,
        rapidMilestonesToClaim: newMilestones.map(m => m.rating),
        amount: totalUnpaid
      };

      return {
        isChef,
        baselineT,
        baselineR,
        tactics: {
          now: tNow,
          rewardRaw: tacticsRewardRaw,
          paid: tacticsPaid,
          unpaid: tacticsUnpaid,
          toNext: tacticsToNext
        },
        rapid: {
          now: rNow,
          rewardRaw: rapidRewardRaw,
          paid: rapidPaid,
          unpaid: rapidUnpaid
        },
        total: {
          raw: totalRaw,
          paid: totalPaid,
          unpaid: totalUnpaid
        },
        rapidMilestones: {
          baseline: baselineR,
          details: milestoneDetails
        },
        eloSteps,
        claimable,
        pending
      };
    }

    async function createLifetimeClaim(username, rewardState) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);

      const { claimable } = rewardState;
      if (claimable.amount <= 0) return;

      const pendingClaim = {
        status: "requested",
        amount: claimable.amount,
        tacticsStepsToClaim: claimable.tacticsStepsToClaim,
        rapidStepsToClaim: claimable.rapidStepsToClaim,
        rapidMilestonesToClaim: claimable.rapidMilestonesToClaim,
        createdAt: serverTimestamp()
      };

      await updateDoc(ref, {
        pendingClaim,
        updatedAt: serverTimestamp()
      });
    }

    async function markLifetimeClaimPaid(username, rewardState) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      const pending = rewardState.pending;
      if (!pending || pending.status !== "requested") return;

      const snap = await getDoc(ref);
      if (!snap.exists()) return;
      const data = snap.data();

      const currentTacticsStepsClaimed = data.tacticsStepsClaimed ?? 0;
      const currentRapidStepsClaimed   = data.rapidStepsClaimed ?? 0;
      const currentRapidMilestonesClaimed = data.rapidMilestonesClaimed ?? [];

      const newTacticsStepsClaimed =
        currentTacticsStepsClaimed + (pending.tacticsStepsToClaim || 0);
      const newRapidStepsClaimed =
        currentRapidStepsClaimed + (pending.rapidStepsToClaim || 0);

      const newMilestonesClaimed = Array.from(
        new Set([
          ...currentRapidMilestonesClaimed,
          ...(pending.rapidMilestonesToClaim || [])
        ])
      );

      await updateDoc(ref, {
        tacticsStepsClaimed: newTacticsStepsClaimed,
        rapidStepsClaimed: newRapidStepsClaimed,
        rapidMilestonesClaimed: newMilestonesClaimed,
        pendingClaim: {
          ...pending,
          status: "paid",
          resolvedAt: serverTimestamp()
        },
        updatedAt: serverTimestamp()
      });
    }

    async function resetLifetimeClaim(username) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      await updateDoc(ref, {
        pendingClaim: null,
        updatedAt: serverTimestamp()
      });
    }

    function getCurrentWeekRange() {
      const now = new Date();
      const day = now.getDay(); // 0=So,1=Mo,...6=Sa
      const diffToMonday = (day === 0 ? -6 : 1 - day);
      const monday = new Date(now);
      monday.setHours(0,0,0,0);
      monday.setDate(monday.getDate() + diffToMonday);

      const sunday = new Date(monday);
      sunday.setDate(sunday.getDate() + 6);
      sunday.setHours(23,59,59,999);

      const weekStartMs = monday.getTime();
      const weekEndMs = sunday.getTime();

      const year = monday.getFullYear();
      const weekNumber = getISOWeekNumber(monday);
      const weekKey = `${year}-W${String(weekNumber).padStart(2, "0")}`;

      return { weekStartMs, weekEndMs, weekKey };
    }

    function getISOWeekNumber(date) {
      const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = tmp.getUTCDay() || 7;
      tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 1));
      const weekNo = Math.ceil(((tmp - yearStart) / 86400000 + 1) / 7);
      return weekNo;
    }

    async function loadWeeklyStats(username) {
      const uname = username.toLowerCase();
      const { weekStartMs, weekEndMs } = getCurrentWeekRange();

      const startDate = new Date(weekStartMs);
      const endDate = new Date(weekEndMs);

      const months = getMonthsBetween(startDate, endDate);
      let totalGamesWeek = 0;
      let rapidGamesWeek = 0;
      let timeoutsWeek = 0;
      const activeDayIndexes = new Set();

      for (const { year, month } of months) {
        const monthStr = String(month).padStart(2, "0");
        try {
          const data = await fetchJson(`https://api.chess.com/pub/player/${uname}/games/${year}/${monthStr}`);
          const games = data.games || [];
          for (const g of games) {
            if (!g.end_time) continue;
            const endMs = g.end_time * 1000;
            if (endMs < weekStartMs || endMs > weekEndMs) continue;

            totalGamesWeek++;
            if (g.time_class === "rapid") rapidGamesWeek++;

            const whiteUser = g.white && g.white.username && g.white.username.toLowerCase();
            const blackUser = g.black && g.black.username && g.black.username.toLowerCase();
            const unameLower = uname;

            let myResult = null;
            if (whiteUser === unameLower) myResult = g.white.result;
            else if (blackUser === unameLower) myResult = g.black.result;

            if (myResult === "timeout" || myResult === "abandoned") {
              timeoutsWeek++;
            }

            const dayIndex = Math.floor((endMs - weekStartMs) / (24 * 60 * 60 * 1000));
            if (dayIndex >= 0 && dayIndex < 7) activeDayIndexes.add(dayIndex);
          }
        } catch (e) {
          console.error("Fehler beim Laden des Monatsarchivs", year, monthStr, "f√ºr", username, e);
        }
      }

      const activeDaysCount = activeDayIndexes.size;

      return {
        totalGamesWeek,
        rapidGamesWeek,
        activeDaysCount,
        timeoutsWeek
      };
    }

    function getMonthsBetween(startDate, endDate) {
      const months = [];
      let year = startDate.getFullYear();
      let month = startDate.getMonth() + 1;

      while (year < endDate.getFullYear() || (year === endDate.getFullYear() && month <= endDate.getMonth() + 1)) {
        months.push({ year, month });
        month++;
        if (month > 12) {
          month = 1;
          year++;
        }
      }
      return months;
    }

    async function loadWeeklyDoc(username, weekKey) {
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      const snap = await getDoc(ref);

      if (!snap.exists()) {
        const initData = {
          username,
          weekKey,
          goalsPaid: [],
          totalPaid: 0,
          pendingClaim: null,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        };
        await setDoc(ref, initData);
        return initData;
      }

      return snap.data();
    }

    function computeWeeklyState(username, weeklyStats, weeklyDoc, weekKey) {
      const isChef = username === CHEF_USERNAME;
      const goalsPaid = weeklyDoc.goalsPaid || [];
      const totalPaid = weeklyDoc.totalPaid || 0;
      const pending = weeklyDoc.pendingClaim || null;

      const goalStates = WEEKLY_GOALS.map(goal => {
        let fulfilled = false;

        if (goal.id === "rapid10") {
          fulfilled = weeklyStats.rapidGamesWeek >= 10;
        } else if (goal.id === "games20") {
          fulfilled = weeklyStats.totalGamesWeek >= 20;
        } else if (goal.id === "days5") {
          fulfilled = weeklyStats.activeDaysCount >= 5;
        } else if (goal.id === "days7") {
          fulfilled = weeklyStats.activeDaysCount >= 7;
        } else if (goal.id === "noTimeouts") {
          fulfilled = weeklyStats.totalGamesWeek > 0 && weeklyStats.timeoutsWeek === 0;
        }

        const alreadyPaid = goalsPaid.includes(goal.id);

        return {
          id: goal.id,
          label: goal.label,
          amount: goal.amount,
          fulfilled,
          alreadyPaid
        };
      });

      const potentialGoals = goalStates.filter(g => g.fulfilled && !g.alreadyPaid);
      let remainingCap = Math.max(0, WEEKLY_CAP - totalPaid);
      let claimAmount = 0;
      const claimGoalIds = [];

      for (const g of potentialGoals) {
        if (g.amount <= remainingCap) {
          claimAmount += g.amount;
          claimGoalIds.push(g.id);
          remainingCap -= g.amount;
        }
      }

      const unpaid = claimAmount;
      const rawEarned = totalPaid + potentialGoals.reduce((s, g) => s + g.amount, 0);

      return {
        isChef,
        weekKey,
        weeklyStats,
        goalStates,
        totalPaid,
        unpaid,
        rawEarned,
        pending,
        claimPlan: {
          amount: claimAmount,
          goalIds: claimGoalIds
        }
      };
    }

    async function createWeeklyClaim(username, weeklyState) {
      const { claimPlan, weekKey } = weeklyState;
      if (claimPlan.amount <= 0) return;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);

      const pendingClaim = {
        status: "requested",
        amount: claimPlan.amount,
        goals: claimPlan.goalIds,
        createdAt: serverTimestamp()
      };

      await updateDoc(ref, {
        pendingClaim,
        updatedAt: serverTimestamp()
      });
    }

    async function markWeeklyClaimPaid(username, weeklyState) {
      const { weekKey } = weeklyState;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      const pending = weeklyState.pending;
      if (!pending || pending.status !== "requested") return;

      const snap = await getDoc(ref);
      if (!snap.exists()) return;
      const data = snap.data();

      const goalsPaid = data.goalsPaid || [];
      const totalPaid = data.totalPaid || 0;

      const newGoalsPaid = Array.from(new Set([...goalsPaid, ...(pending.goals || [])]));
      const newTotalPaid = totalPaid + (pending.amount || 0);

      await updateDoc(ref, {
        goalsPaid: newGoalsPaid,
        totalPaid: newTotalPaid,
        pendingClaim: {
          ...pending,
          status: "paid",
          resolvedAt: serverTimestamp()
        },
        updatedAt: serverTimestamp()
      });
    }

    async function resetWeeklyClaim(username, weeklyState) {
      const { weekKey } = weeklyState;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      await updateDoc(ref, {
        pendingClaim: null,
        updatedAt: serverTimestamp()
      });
    }

    function buildAchievements(stats, rewardState) {
      const { totalGames, modes, tactics } = stats;
      const { total } = rewardState;
      const ach = [];

      if (totalGames >= 100) {
        ach.push({ label: "üèÉ Grinder", style: "silver" });
      } else if (totalGames >= 50) {
        ach.push({ label: "üéØ Warmgelaufen", style: "bronze" });
      }

      const modesWithGames = modes.filter(m => m.games >= 20 && m.winrate != null);
      if (modesWithGames.length) {
        modesWithGames.sort((a, b) => b.winrate - a.winrate);
        const best = modesWithGames[0];
        if (best.winrate >= 60) {
          ach.push({ label: `üî• ${best.label}`, style: "gold" });
        }
      }

      if (total.raw >= 50) {
        ach.push({ label: "üí∂ Rewards", style: "silver" });
      }

      if (tactics && tactics.current != null && tactics.current >= 2200) {
        ach.push({ label: "üß† Tactics", style: "gold" });
      }

      return ach.slice(0, 3);
    }

    function buildFocus(stats, rewardState) {
      const { tactics } = stats;
      const { rapid, tactics: tState } = rewardState;

      if (rapid.unpaid > 0) {
        return {
          title: "Rapid",
          text: `Rapid spielen, um <strong>${rapid.unpaid} ‚Ç¨</strong> klarzumachen.`
        };
      }

      if (tState.unpaid > 0) {
        return {
          title: "Taktik",
          text: `Taktik pushen f√ºr <strong>${tState.unpaid} ‚Ç¨</strong> Extra.`
        };
      }

      if (tactics && tactics.current != null) {
        return {
          title: "Warmup",
          text: `Kurz Taktik (${tactics.current}) und dann Partien.`
        };
      }

      return {
        title: "Einfach spielen",
        text: "Format aussuchen, ein paar konzentrierte Games machen."
      };
    }

    function renderPlayerCard(stats, rewardState, weeklyState) {
      const cards = document.getElementById("cards");
      const card = document.createElement("article");
      card.className = "card";

      const header = document.createElement("div");
      header.className = "card-header";

      const left = document.createElement("div");
      left.className = "card-title-block";

      if (stats.avatar) {
        const img = document.createElement("img");
        img.src = stats.avatar;
        img.alt = stats.username;
        img.className = "avatar";
        left.appendChild(img);
      }

      const nameEl = document.createElement("div");
      nameEl.className = "username";
      nameEl.textContent = stats.username;
      left.appendChild(nameEl);

      header.appendChild(left);

      const status = document.createElement("div");
      status.className = "status-badge " + (stats.active ? "status-active" : "status-chill");
      status.textContent = stats.active ? "AKTIV" : "PAUSE";
      header.appendChild(status);

      card.appendChild(header);

      const modesTitle = document.createElement("div");
      modesTitle.className = "section-title";
      modesTitle.textContent = "Ratings";
      card.appendChild(modesTitle);

      const modesWrap = document.createElement("div");
      modesWrap.className = "modes";

      if (!stats.modes.length) {
        const p = document.createElement("div");
        p.style.fontSize = "0.76rem";
        p.style.color = "#9ca3af";
        p.textContent = "Keine Partiedaten.";
        modesWrap.appendChild(p);
      } else {
        stats.modes.forEach(m => {
          const row = document.createElement("div");
          row.className = "mode-row";

          const leftCol = document.createElement("div");
          leftCol.className = "mode-left";

          const label = document.createElement("div");
          label.className = "mode-label";
          label.innerHTML = `${m.icon} ${m.label}`;
          leftCol.appendChild(label);

          const meta = document.createElement("div");
          meta.className = "mode-meta";
          const winrateText = m.winrate != null ? `${m.winrate}%` : "‚Äì";
          meta.textContent = `${m.games} G ¬∑ WR ${winrateText}`;
          leftCol.appendChild(meta);

          const rightCol = document.createElement("div");
          rightCol.className = "mode-right";

          const current = document.createElement("div");
          current.innerHTML = `<span class="rating">${m.current ?? "‚Äì"}</span>`;
          rightCol.appendChild(current);

          const gapText = document.createElement("div");
          if (m.best != null && m.current != null) {
            const gap = m.best - m.current;
            let cls = "gap-mid";
            let labelText = "";
            if (gap <= 0) {
              cls = "gap-good";
              labelText = "PB";
            } else if (gap <= 50) {
              cls = "gap-good";
              labelText = `-${gap}`;
            } else if (gap <= 100) {
              cls = "gap-mid";
              labelText = `-${gap}`;
            } else {
              cls = "gap-bad";
              labelText = `-${gap}`;
            }
            gapText.innerHTML = `<span class="${cls}">${labelText}</span>`;
          } else {
            gapText.textContent = "‚Äî";
          }
          rightCol.appendChild(gapText);

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          modesWrap.appendChild(row);
        });
      }

      card.appendChild(modesWrap);

      const achTitle = document.createElement("div");
      achTitle.className = "section-title";
      achTitle.textContent = "Badges";
      card.appendChild(achTitle);

      const achRow = document.createElement("div");
      achRow.className = "badge-row";
      const achievements = buildAchievements(stats, rewardState);

      if (!achievements.length) {
        const span = document.createElement("span");
        span.style.color = "#9ca3af";
        span.style.fontSize = "0.72rem";
        span.textContent = "Noch keine Badges.";
        achRow.appendChild(span);
      } else {
        achievements.forEach(a => {
          const span = document.createElement("span");
          span.className = `badge ${a.style}`;
          span.textContent = a.label;
          achRow.appendChild(span);
        });
      }
      card.appendChild(achRow);

      const focusTitle = document.createElement("div");
      focusTitle.className = "section-title";
      focusTitle.textContent = "Fokus";
      card.appendChild(focusTitle);

      const focusInfo = buildFocus(stats, rewardState);
      const focus = document.createElement("div");
      focus.className = "focus";
      focus.innerHTML = `<strong>${focusInfo.title}</strong> ¬∑ ${focusInfo.text}`;
      card.appendChild(focus);

      // Lebenszeit-Rewards ‚Äì nicht f√ºr Chef
      if (!rewardState.isChef) {
        const rewardTitle = document.createElement("div");
        rewardTitle.className = "section-title";
        rewardTitle.textContent = "Belohnungen (Lifetime)";
        card.appendChild(rewardTitle);

        const rewardBox = document.createElement("div");
        rewardBox.className = "focus";

        const { tactics, rapid, total, pending, rapidMilestones, eloSteps } = rewardState;
        const activePending = pending && pending.status === "requested" ? pending : null;

        rewardBox.innerHTML = `
          <div class="reward-row">
            <span class="reward-label">Theorie:</span>
            <span class="reward-value">${total.raw} ‚Ç¨</span>
            <span class="reward-label">Ausgezahlt:</span>
            <span class="reward-value">${total.paid} ‚Ç¨</span>
          </div>
          <div class="reward-row">
            <span class="reward-label">Offen:</span>
            <span class="reward-value">${total.unpaid} ‚Ç¨</span>
            <span class="reward-label">Taktik / Rapid:</span>
            <span class="reward-value">${tactics.rewardRaw} / ${rapid.rewardRaw} ‚Ç¨</span>
          </div>
        `;

        // Elo-Steps (Rapid & Taktik) ‚Äì visual
        if (eloSteps) {
          const stepContainer = document.createElement("div");
          stepContainer.className = "step-sections";

          const mapping = [
            { key: "rapid", label: "Rapid-Elo Steps" },
            { key: "tactics", label: "Taktik-Elo Steps" }
          ];

          mapping.forEach(cfg => {
            const group = eloSteps[cfg.key];
            if (!group) return;

            const section = document.createElement("div");
            section.className = "step-section";

            const header = document.createElement("div");
            header.className = "step-header";

            const leftLabel = document.createElement("div");
            leftLabel.className = "step-label";
            leftLabel.textContent = cfg.label;

            const rightInfo = document.createElement("div");
            rightInfo.innerHTML = `
              <span class="step-current">${group.current ?? "‚Äì"} Elo</span>
              <span class="step-summary"> ¬∑ ${group.paid}/${group.total} Steps bezahlt, ${group.open} offen</span>
            `;

            header.appendChild(leftLabel);
            header.appendChild(rightInfo);
            section.appendChild(header);

            const grid = document.createElement("div");
            grid.className = "step-grid";

            group.details.forEach(step => {
              const item = document.createElement("div");
              let cls = "step-locked";
              if (step.status === "paid") cls = "step-paid";
              else if (step.status === "open") cls = "step-open";

              item.className = `step-item ${cls}`;
              item.title = `Step #${step.index} ¬∑ ${step.rating} Elo`;
              item.innerHTML = `<span>${step.rating}</span>`;
              grid.appendChild(item);
            });

            section.appendChild(grid);
            stepContainer.appendChild(section);
          });

          rewardBox.appendChild(stepContainer);
        }

        // Rapid-Meilensteine: erreicht / bezahlt / offen
        if (rapidMilestones && rapidMilestones.details && rapidMilestones.details.length) {
          const msList = document.createElement("div");
          msList.className = "weekly-goals";

          rapidMilestones.details.forEach(ms => {
            const row = document.createElement("div");
            row.className = "weekly-goal-row";

            const leftCol = document.createElement("div");
            leftCol.className = "weekly-goal-name";
            leftCol.textContent = `Rapid ${ms.rating} (${ms.reward} ‚Ç¨)`;

            const rightCol = document.createElement("div");
            rightCol.className = "weekly-goal-status";

            if (ms.paid) {
              rightCol.innerHTML = `<span class="status-paid">bezahlt</span>`;
            } else if (ms.reached) {
              rightCol.innerHTML = `<span class="status-ok">erreicht</span>`;
            } else {
              rightCol.innerHTML = `<span class="status-missing">offen</span>`;
            }

            row.appendChild(leftCol);
            row.appendChild(rightCol);
            msList.appendChild(row);
          });

          rewardBox.appendChild(msList);
        }

        const chip = document.createElement("div");
        let chipClass, chipText;
        if (activePending) {
          chipClass = "chip-requested";
          chipText = `Claim offen: ${activePending.amount} ‚Ç¨`;
        } else if (total.unpaid > 0) {
          chipClass = "chip-open";
          chipText = `Offen: ${total.unpaid} ‚Ç¨`;
        } else {
          chipClass = "chip-paid";
          chipText = "Alles ausgezahlt.";
        }
        chip.className = `reward-chip ${chipClass}`;
        chip.textContent = chipText;
        rewardBox.appendChild(chip);

        if (!activePending && total.unpaid > 0) {
          const btn = document.createElement("button");
          btn.className = "btn";
          btn.textContent = `Claim (${total.unpaid} ‚Ç¨)`;
          btn.addEventListener("click", async () => {
            btn.disabled = true;
            await createLifetimeClaim(stats.username, rewardState);
            location.reload();
          });
          rewardBox.appendChild(btn);
        } else if (activePending) {
          const btnPaid = document.createElement("button");
          btnPaid.className = "btn";
          btnPaid.textContent = `Ausgezahlt (${activePending.amount} ‚Ç¨)`;
          btnPaid.addEventListener("click", async () => {
            btnPaid.disabled = true;
            await markLifetimeClaimPaid(stats.username, rewardState);
            location.reload();
          });
          rewardBox.appendChild(btnPaid);

          const btnCancel = document.createElement("button");
          btnCancel.className = "btn btn-danger";
          btnCancel.textContent = "Reset";
          btnCancel.addEventListener("click", async () => {
            btnCancel.disabled = true;
            await resetLifetimeClaim(stats.username);
            location.reload();
          });
          rewardBox.appendChild(btnCancel);
        }

        card.appendChild(rewardBox);
      }

      // Weekly ‚Äì auch nicht f√ºr Chef
      if (!weeklyState.isChef) {
        const weeklyTitle = document.createElement("div");
        weeklyTitle.className = "section-title";
        weeklyTitle.textContent = "Weekly Bonus";
        card.appendChild(weeklyTitle);

        const weeklyBox = document.createElement("div");
        weeklyBox.className = "focus";

        const { weeklyStats, goalStates, unpaid, totalPaid, pending, claimPlan, weekKey } = weeklyState;
        const activePending = pending && pending.status === "requested" ? pending : null;

        weeklyBox.innerHTML = `
          <div style="font-size:0.74rem;margin-bottom:0.25rem;">
            ${weekKey} ¬∑ ${weeklyStats.totalGamesWeek} G (${weeklyStats.rapidGamesWeek} Rapid) ¬∑ ${weeklyStats.activeDaysCount}/7 Tage ¬∑ TO: ${weeklyStats.timeoutsWeek}
          </div>
          <div class="reward-row">
            <span class="reward-label">Paid Woche:</span>
            <span class="reward-value">${totalPaid} ‚Ç¨</span>
            <span class="reward-label">Offen:</span>
            <span class="reward-value">${unpaid} ‚Ç¨</span>
          </div>
        `;

        const goalsDiv = document.createElement("div");
        goalsDiv.className = "weekly-goals";

        goalStates.forEach(g => {
          const row = document.createElement("div");
          row.className = "weekly-goal-row";

          const leftCol = document.createElement("div");
          leftCol.className = "weekly-goal-name";
          leftCol.textContent = `${g.label} (${g.amount} ‚Ç¨)`;

          const rightCol = document.createElement("div");
          rightCol.className = "weekly-goal-status";

          if (g.alreadyPaid) {
            rightCol.innerHTML = `<span class="status-paid">bezahlt</span>`;
          } else if (g.fulfilled) {
            rightCol.innerHTML = `<span class="status-ok">ok</span>`;
          } else {
            rightCol.innerHTML = `<span class="status-missing">offen</span>`;
          }

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          goalsDiv.appendChild(row);
        });

        weeklyBox.appendChild(goalsDiv);

        const chip = document.createElement("div");
        let chipClass, chipText;
        if (activePending) {
          chipClass = "chip-requested";
          chipText = `Weekly-Claim: ${activePending.amount} ‚Ç¨`;
        } else if (unpaid > 0) {
          chipClass = "chip-open";
          chipText = `Offen: ${unpaid} ‚Ç¨`;
        } else {
          chipClass = "chip-paid";
          chipText = "Weekly voll.";
        }
        chip.className = `reward-chip ${chipClass}`;
        chip.textContent = chipText;
        weeklyBox.appendChild(chip);

        if (!activePending && claimPlan.amount > 0) {
          const btn = document.createElement("button");
          btn.className = "btn";
          btn.textContent = `Claim (${claimPlan.amount} ‚Ç¨)`;
          btn.addEventListener("click", async () => {
            btn.disabled = true;
            await createWeeklyClaim(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btn);
        } else if (activePending) {
          const btnPaid = document.createElement("button");
          btnPaid.className = "btn";
          btnPaid.textContent = `Ausgezahlt (${activePending.amount} ‚Ç¨)`;
          btnPaid.addEventListener("click", async () => {
            btnPaid.disabled = true;
            await markWeeklyClaimPaid(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btnPaid);

          const btnCancel = document.createElement("button");
          btnCancel.className = "btn btn-danger";
          btnCancel.textContent = "Reset";
          btnCancel.addEventListener("click", async () => {
            btnCancel.disabled = true;
            await resetWeeklyClaim(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btnCancel);
        }

        card.appendChild(weeklyBox);
      }

      cards.appendChild(card);
    }

    function renderSquad(players) {
      const container = document.getElementById("squad");
      container.innerHTML = "";

      const card = document.createElement("div");
      card.className = "squad-card";

      const title = document.createElement("div");
      title.className = "squad-title";
      title.innerHTML = "üí¨ Squad-Overview";
      card.appendChild(title);

      const list = document.createElement("div");
      list.className = "squad-list";

      const allModes = [];
      players.forEach(p => p.stats.modes.forEach(m => allModes.push({ player: p.stats.username, ...m })));
      const rapid = allModes.filter(m => m.key === "chess_rapid" && m.current != null);
      if (rapid.length) {
        rapid.sort((a, b) => b.current - a.current);
        const r = rapid[0];
        list.innerHTML += `<div>üèÜ Rapid-Top: <strong>${r.player}</strong> (${r.current})</div>`;
      }

      const activeCount = players.filter(p => p.stats.active).length;
      list.innerHTML += `<div>üìÜ Aktiv: <strong>${activeCount}/${players.length}</strong></div>`;

      card.appendChild(list);
      container.appendChild(card);
    }

    async function init() {
      const subtitle = document.getElementById("subtitle");
      subtitle.textContent = "Lade Chess.com & Firestore‚Ä¶";

      const { weekKey } = getCurrentWeekRange();
      const playersCombined = [];

      for (const name of PLAYERS) {
        try {
          const stats = await loadChessStats(name);
          const [rewardDoc, weeklyStats, weeklyDoc] = await Promise.all([
            loadRewardDoc(name, stats.tacticsRating, stats.rapidRating),
            loadWeeklyStats(name),
            loadWeeklyDoc(name, weekKey)
          ]);

          const rewardState = computeRewardState(name, stats.tacticsRating, stats.rapidRating, rewardDoc);
          const weeklyState = computeWeeklyState(name, weeklyStats, weeklyDoc, weekKey);

          playersCombined.push({ stats, rewardState, weeklyState });
          renderPlayerCard(stats, rewardState, weeklyState);
        } catch (e) {
          console.error("Fehler bei Spieler", name, e);
        }
      }

      renderSquad(playersCombined);

      const now = new Date();
      subtitle.textContent = `Stand: ${now.toLocaleString()}`;
    }

    init();
  </script>
</body>
</html>
