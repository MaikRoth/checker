<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Chess Squad ‚Äì Progress Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
  :root {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: #020617;
    color: #e5e7eb;
  }

  html,
  body {
    background:
      radial-gradient(circle at top, rgba(15,23,42,0.9), #020617 55%, #000 100%),
      repeating-linear-gradient(
        45deg,
        rgba(15,23,42,0.18),
        rgba(15,23,42,0.18) 1px,
        transparent 1px,
        transparent 10px
      );
  }

  body {
    margin: 0;
    min-height: 100vh;
    padding: 2rem 1.25rem 3rem;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  main {
    width: 100%;
    max-width: 1100px;
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }

  header {
    text-align: center;
    margin-bottom: 1.6rem;
  }

  h1 {
    margin: 0;
    font-size: clamp(2.1rem, 3.4vw, 2.7rem);
    text-align: center;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    text-shadow: 0 0 24px rgba(59,130,246,0.35);
  }

  header::after {
    content: "";
    display: block;
    width: 72px;
    height: 2px;
    margin: 0.9rem auto 0;
    border-radius: 999px;
    background: linear-gradient(to right, #38bdf8, #a855f7, #ec4899);
    opacity: 0.8;
  }

  .subtitle {
    color: #9ca3af;
    font-size: 0.85rem;
    text-align: center;
    margin-top: 0.4rem;
    min-height: 1.2em;
  }

  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.4rem;
    width: 100%;
  }

  .card {
    background: #020617;
    border-radius: 0.9rem;
    padding: 1rem 1.1rem 1.1rem;
    border: 1px solid #1f2937;
    box-shadow: 0 16px 40px rgba(0,0,0,0.7);
    font-size: 0.8rem;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    position: relative;
    overflow: hidden;
    transition:
      transform 150ms ease-out,
      box-shadow 150ms ease-out,
      border-color 150ms ease-out,
      background 150ms ease-out;
  }

  .card::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(circle at top, rgba(148,163,184,0.25), transparent 55%);
    mix-blend-mode: soft-light;
  }

  .card-inner {
    position: relative;
    z-index: 1;
  }

  .card:hover {
    transform: translateY(-4px) scale(1.01);
    box-shadow: 0 24px 60px rgba(0,0,0,0.85);
    border-color: #4b5563;
  }

  .card:active {
    transform: translateY(-1px) scale(0.995);
    box-shadow: 0 16px 40px rgba(0,0,0,0.75);
  }

  /* M41K */
  .card-admin {
    border-radius: 0.9rem;
    border-color: #38bdf8;
    box-shadow: 0 20px 55px rgba(59,130,246,0.5);
    background: radial-gradient(circle at top left, #0f172a, #020617 55%, #020617);
  }

  .card-admin::before {
    background:
      radial-gradient(circle at 0% 0%, rgba(59,130,246,0.35), transparent 60%),
      radial-gradient(circle at 100% 0%, rgba(56,189,248,0.2), transparent 55%);
    mix-blend-mode: screen;
    opacity: 0.9;
  }

  .card-admin:hover {
    box-shadow: 0 26px 70px rgba(56,189,248,0.65);
  }

  /* ERR_Daemon ‚Äì gr√ºn/gold */
  .card-pay {
    border-color: #22c55e;
    box-shadow: 0 22px 60px rgba(34,197,94,0.45);
    background: radial-gradient(circle at top left, #052e16, #020617 60%);
  }

  .card-pay::before {
    background:
      radial-gradient(circle at 0% 0%, rgba(34,197,94,0.35), transparent 60%),
      radial-gradient(circle at 100% 0%, rgba(250,204,21,0.25), transparent 55%);
    mix-blend-mode: screen;
    opacity: 0.9;
  }

  .card-pay:hover {
    box-shadow: 0 26px 70px rgba(34,197,94,0.6);
  }

  /* Kathi ‚Äì pink/lila */
  .card-gf {
    border-color: #ec4899;
    box-shadow: 0 22px 60px rgba(236,72,153,0.45);
    background: radial-gradient(circle at top left, #4c1d95, #020617 60%);
  }

  .card-gf::before {
    background:
      radial-gradient(circle at 0% 0%, rgba(236,72,153,0.35), transparent 60%),
      radial-gradient(circle at 100% 0%, rgba(129,140,248,0.25), transparent 55%);
    mix-blend-mode: screen;
    opacity: 0.9;
  }

  .card-gf:hover {
    box-shadow: 0 26px 70px rgba(236,72,153,0.6);
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    gap: 0.75rem;
    align-items: center;
    margin-bottom: 0.3rem;
  }

  .card-title-block {
    display: flex;
    align-items: center;
    gap: 0.55rem;
  }

  .avatar {
    width: 32px;
    height: 32px;
    border-radius: 999px;
    border: 2px solid #38bdf8;
    object-fit: cover;
    background: #020617;
    flex-shrink: 0;
    box-shadow:
      0 0 0 2px rgba(15,23,42,1),
      0 0 0 4px rgba(56,189,248,0.6);
  }

  .card-pay .avatar {
    box-shadow:
      0 0 0 2px rgba(15,23,42,1),
      0 0 0 4px rgba(34,197,94,0.6);
  }

  .card-gf .avatar {
    box-shadow:
      0 0 0 2px rgba(15,23,42,1),
      0 0 0 4px rgba(236,72,153,0.6);
  }

  .username {
    font-weight: 600;
    font-size: 0.95rem;
    letter-spacing: 0.02em;
  }

  .status-badge {
    padding: 0.18rem 0.7rem;
    border-radius: 999px;
    font-size: 0.7rem;
    font-weight: 600;
    border: 1px solid transparent;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    backdrop-filter: blur(10px);
    background: linear-gradient(
      135deg,
      rgba(15,23,42,0.85),
      rgba(15,23,42,0.4)
    );
  }

  .status-active {
    background: rgba(34,197,94,0.15);
    color: #bbf7d0;
    border-color: rgba(34,197,94,0.5);
  }

  .status-chill {
    background: rgba(148,163,184,0.12);
    color: #e5e7eb;
    border-color: rgba(148,163,184,0.4);
  }

  .status-admin {
    background: rgba(59,130,246,0.16);
    color: #bfdbfe;
    border-color: rgba(59,130,246,0.75);
  }

  .status-gf {
    background: rgba(236,72,153,0.16);
    color: #f9a8d4;
    border-color: rgba(236,72,153,0.75);
  }

  .section-title {
    margin-top: 0.4rem;
    font-size: 0.76rem;
    font-weight: 600;
    color: #d1d5db;
    letter-spacing: 0.12em;
    text-transform: uppercase;
  }

  .section-subtitle {
    margin-top: 0.1rem;
    font-size: 0.72rem;
    color: #9ca3af;
  }

  .modes {
    margin-top: 0.2rem;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    font-size: 0.76rem;
  }

  .mode-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    padding: 0.25rem 0.4rem;
    border-radius: 0.55rem;
    background: rgba(15,23,42,0.9);
    border: 1px solid rgba(30,64,175,0.7);
    position: relative;
    overflow: hidden;
    transition:
      background 120ms ease-out,
      border-color 120ms ease-out,
      transform 120ms ease-out;
  }

  .mode-row::before {
    content: "";
    position: absolute;
    inset: 0;
    opacity: 0;
    background: radial-gradient(circle at top left, rgba(56,189,248,0.16), transparent 55%);
    transition: opacity 150ms ease-out;
    pointer-events: none;
  }

  .mode-row:hover {
    background: rgba(15,23,42,0.95);
    border-color: rgba(56,189,248,0.9);
    transform: translateY(-1px);
  }

  .mode-row:hover::before {
    opacity: 1;
  }

  .mode-left {
    display: flex;
    flex-direction: column;
    gap: 0.1rem;
  }

  .mode-label {
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 0.35rem;
  }

  .mode-meta {
    color: #9ca3af;
    font-size: 0.7rem;
  }

  .mode-right {
    text-align: right;
    font-size: 0.74rem;
  }

  .rating {
    font-weight: 600;
    color: #facc15;
  }

  .gap-good {
    color: #22c55e;
  }
  .gap-mid {
    color: #eab308;
  }
  .gap-bad {
    color: #f97316;
  }

  .badge-row {
    margin-top: 0.25rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    font-size: 0.7rem;
  }

  .badge {
    padding: 0.15rem 0.45rem;
    border-radius: 999px;
    border: 1px solid #1f2937;
    background: rgba(15,23,42,0.95);
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    white-space: nowrap;
    cursor: default;
  }

  .badge.gold {
    border-color: #fbbf24;
    color: #facc15;
  }

  .badge.silver {
    border-color: #9ca3af;
    color: #e5e7eb;
  }

  .badge.bronze {
    border-color: #f97316;
    color: #fed7aa;
  }

  .reward-chip {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.12rem 0.5rem;
    border-radius: 999px;
    font-size: 0.7rem;
    margin-top: 0.25rem;
  }

  .chip-open {
    background: rgba(234,179,8,0.15);
    border: 1px solid #eab308;
    color: #fde68a;
  }

  .chip-requested {
    background: rgba(59,130,246,0.15);
    border: 1px solid #3b82f6;
    color: #bfdbfe;
  }

  .chip-paid {
    background: rgba(34,197,94,0.15);
    border: 1px solid #22c55e;
    color: #bbf7d0;
  }

  .btn {
    margin-top: 0.45rem;
    padding: 0.32rem 0.9rem;
    border-radius: 999px;
    border: none;
    background: linear-gradient(135deg, #22c55e, #16a34a);
    color: #022c22;
    font-size: 0.74rem;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 10px 22px rgba(22,163,74,0.45);
    transition:
      transform 130ms ease-out,
      box-shadow 130ms ease-out,
      filter 130ms ease-out;
  }

  .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 14px 30px rgba(22,163,74,0.55);
    filter: brightness(1.02);
  }

  .btn-danger {
    border: none;
    background: linear-gradient(135deg, #ef4444, #b91c1c);
    color: #fee2e2;
    margin-left: 0.3rem;
    box-shadow: 0 10px 22px rgba(239,68,68,0.45);
  }

  .weekly-goals {
    margin-top: 0.25rem;
    font-size: 0.74rem;
    display: flex;
    flex-direction: column;
    gap: 0.18rem;
  }

  .weekly-goal-row {
    display: flex;
    justify-content: space-between;
    gap: 0.4rem;
    padding: 0.18rem 0.3rem;
    border-radius: 0.45rem;
    background: rgba(15,23,42,0.8);
  }

  .weekly-goal-name {
    font-weight: 500;
  }

  .weekly-goal-status {
    font-size: 0.72rem;
    text-align: right;
  }

  .status-ok {
    color: #bbf7d0;
  }

  .status-paid {
    color: #93c5fd;
  }

  .status-missing {
    color: #facc15;
  }

  footer {
    font-size: 0.72rem;
    color: #6b7280;
    text-align: center;
    margin-top: 1.2rem;
  }

  a {
    color: #60a5fa;
  }

  /* Elo-Step-Ansicht */
  .step-sections {
    margin-top: 0.3rem;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }

  .step-section {
    font-size: 0.74rem;
  }

  .step-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 0.12rem;
  }

  .step-label {
    font-weight: 600;
    color: #e5e7eb;
  }

  .step-current {
    font-weight: 600;
    color: #facc15;
  }

  .step-summary {
    font-size: 0.7rem;
    color: #9ca3af;
  }

  .step-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
    margin-top: 0.05rem;
  }

  .step-item {
    min-width: 48px;
    padding: 0.16rem 0.5rem;
    border-radius: 999px;
    font-size: 0.68rem;
    text-align: center;
    border: 1px solid;
    box-sizing: border-box;
  }

  .step-item span {
    display: inline-block;
  }

  .step-paid {
    background: rgba(34,197,94,0.2);
    border-color: #22c55e;
    color: #bbf7d0;
    box-shadow: 0 0 12px rgba(34,197,94,0.45);
  }

  .step-open {
    background: rgba(59,130,246,0.22);
    border-color: #3b82f6;
    color: #bfdbfe;
    box-shadow: 0 0 12px rgba(59,130,246,0.4);
  }

  .step-locked {
    background: rgba(15,23,42,0.95);
    border-color: #1f2937;
    color: #6b7280;
  }

  .step-baseline {
    background: rgba(15,23,42,0.9);
    border-style: dashed;
    border-color: #374151;
    color: #4b5563;
    opacity: 0.7;
  }

  /* Admin / M41K View */
  .admin-summary {
    margin-top: 0.2rem;
    font-size: 0.78rem;
    padding: 0.45rem 0.4rem 0.45rem;
    border-radius: 0.6rem;
    background: rgba(15,23,42,0.95);
    border: 1px solid rgba(55,65,81,0.9);
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .admin-row {
    display: flex;
    justify-content: space-between;
    gap: 0.4rem;
  }

  .admin-label {
    color: #9ca3af;
  }

  .admin-value {
    font-weight: 600;
  }

  .admin-row-muted .admin-value {
    color: #9ca3af;
    font-weight: 500;
  }

  .admin-footnote {
    margin-top: 0.25rem;
    font-size: 0.7rem;
    color: #6b7280;
  }

  .admin-steps {
    border-color: rgba(56,189,248,0.85);
    background: radial-gradient(circle at top, rgba(15,23,42,0.95), #020617 70%);
  }

  .card-admin .step-item {
    font-size: 0.72rem;
    padding: 0.15rem 0.38rem;
  }

  .card-admin .step-paid,
  .card-admin .step-open {
    background: radial-gradient(circle, rgba(56,189,248,0.35), rgba(15,23,42,0.9));
    border-color: #38bdf8;
    color: #e0f2fe;
  }

  /* Freundin-Extras */
  .gf-journey-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 0.18rem;
    font-size: 0.74rem;
  }

  .gf-journey-label {
    font-weight: 600;
    color: #f9a8d4;
    display: flex;
    align-items: center;
    gap: 0.3rem;
  }

  .gf-tagline {
    font-size: 0.7rem;
    color: #f9a8d4;
    opacity: 0.9;
  }

  .gf-dot-row {
    display: flex;
    gap: 0.16rem;
    margin-top: 0.1rem;
    flex-wrap: wrap;
  }

  .gf-dot {
    width: 14px;
    height: 14px;
    border-radius: 999px;
    border: 1px solid #4b5563;
    background: rgba(15,23,42,0.95);
  }

  .gf-dot-reached {
    background: radial-gradient(circle, #f9a8d4, #be185d);
    border-color: #f9a8d4;
  }

  .gf-note {
    font-size: 0.7rem;
    color: #9ca3af;
    margin-top: 0.2rem;
  }

  @media (max-width: 640px) {
    body {
      padding: 1.4rem 0.9rem 2.2rem;
    }

    .card {
      padding: 0.9rem 0.9rem 1rem;
      border-radius: 0.8rem;
    }

    .grid {
      gap: 1rem;
    }
  }
</style>

</head>
<body>
  <main>
    <header style="text-align:center;">
      <h1>Chess Squad ‚Äì Progress Board</h1>
      <p class="subtitle" id="subtitle">
        Lade Live-Daten von Chess.com‚Ä¶
      </p>
    </header>

    <section class="grid" id="cards"></section>

    <footer>
      Datenquelle: <a href="https://www.chess.com/news/view/published-data-api" target="_blank" rel="noreferrer">Chess.com API</a> ¬∑ Backend: Firebase
    </footer>
  </main>

  <script type="module">
    // Fehler-Handler, damit du sofort siehst, wenn JS crasht
    window.addEventListener("error", (event) => {
      const el = document.getElementById("subtitle");
      if (el) el.textContent = "Fehler: " + (event.message || "Unbekannter Fehler ‚Äì siehe Konsole");
    });

    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js';
    import {
      getFirestore,
      doc,
      getDoc,
      setDoc,
      updateDoc,
      serverTimestamp
    } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBtEkLjoW0pEqxOodau5dAArMkkf1hgjnc",
      authDomain: "chess-rewards.firebaseapp.com",
      projectId: "chess-rewards",
      storageBucket: "chess-rewards.firebasestorage.app",
      messagingSenderId: "118996095284",
      appId: "1:118996095284:web:0a80d27fe93668563cd561"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const PLAYERS = ["ERR_Daemon", "M41K", "Kathi_2905"];
    const CHEF_USERNAME = "M41K";
    const PAY_USER_USERNAME = "ERR_Daemon";
    const GIRLFRIEND_USERNAME = "Kathi_2905";

    const MODES = [
      { key: "chess_rapid", label: "Rapid",  icon: "‚è±Ô∏è" },
      { key: "chess_blitz", label: "Blitz",  icon: "‚ö°" },
      { key: "chess_bullet",label: "Bullet", icon: "üí£" },
      { key: "chess_daily", label: "Daily",  icon: "üì¨" },
    ];

    const RAPID_MILESTONES = [
      { rating: 500,  reward:  50 },
      { rating: 1000, reward: 100 },
      { rating: 1500, reward: 150 },
      { rating: 2000, reward: 200 }
    ];

    const REWARD_COLLECTION = "rewardProgress";

    const WEEKLY_COLLECTION = "weeklyActivity";
    const WEEKLY_CAP = 10;

    const WEEKLY_GOALS = [
      { id: "rapid10",  label: "10 Rapid-Games", amount: 3 },
      { id: "games20",  label: "20 Games gesamt", amount: 3 },
      { id: "days5",    label: "5 aktive Tage", amount: 3 },
      { id: "days7",    label: "7/7 Tage aktiv", amount: 5 },
      { id: "noTimeouts", label: "Kein Timeout", amount: 2 }
    ];

    const RAPID_MAX_STEP_RATING = 2500;
    const TACTICS_MAX_STEP_RATING = 3000;

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error("HTTP " + res.status + " f√ºr " + url);
      return res.json();
    }

    async function loadChessStats(username) {
      const uname = username.toLowerCase();
      const [profile, stats] = await Promise.allSettled([
        fetchJson(`https://api.chess.com/pub/player/${uname}`),
        fetchJson(`https://api.chess.com/pub/player/${uname}/stats`)
      ]);

      const profileData = profile.status === "fulfilled" ? profile.value : {};
      const statsData   = stats.status === "fulfilled"   ? stats.value   : {};

      const modes = MODES.map(m => extractMode(statsData, m.key, m.label, m.icon))
        .filter(Boolean);

      const tactics = extractTactics(statsData);

      const totalGames = modes.reduce((sum, m) => sum + m.games, 0);
      const active = totalGames > 0;

      const tacticsRating = tactics?.current ?? null;
      const rapidMode = modes.find(m => m.key === "chess_rapid");
      const rapidRating = rapidMode?.current ?? null;

      return {
        username,
        avatar: profileData.avatar || null,
        url: profileData.url || null,
        modes,
        tactics,
        totalGames,
        active,
        tacticsRating,
        rapidRating
      };
    }

    function extractMode(stats, key, label, icon) {
      const s = stats[key];
      if (!s || !s.last || !s.record) return null;

      const current = s.last.rating ?? null;
      const best    = s.best && s.best.rating != null ? s.best.rating : null;
      const rec     = s.record || {};
      const wins  = rec.win   || 0;
      const loss  = rec.loss  || 0;
      const draw  = rec.draw  || 0;
      const games = wins + loss + draw;
      const winrate = games ? Math.round((wins / games) * 100) : null;
      const gap = (best != null && current != null) ? best - current : null;

      return {
        key,
        label,
        icon,
        current,
        best,
        wins,
        loss,
        draw,
        games,
        winrate,
        gap
      };
    }

    function extractTactics(stats) {
      const t = stats.tactics;
      if (!t) return null;
      const last    = t.last || {};
      const highest = t.highest || {};
      const current = last.rating ?? highest.rating ?? null;
      return {
        current,
        highest: highest.rating ?? null
      };
    }

    async function loadRewardDoc(username, tacticsRating, rapidRating) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      const snap = await getDoc(ref);

      if (!snap.exists()) {
        const baselineTactics = tacticsRating ?? 0;
        const baselineRapid   = rapidRating ?? 0;
        const initData = {
          baselineTactics,
          baselineRapid,
          tacticsStepsClaimed: 0,
          rapidStepsClaimed: 0,
          rapidMilestonesClaimed: [],
          pendingClaim: null,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        };
        await setDoc(ref, initData);
        return initData;
      }

      return snap.data();
    }

    // Steps, jetzt mit maxRating-Parameter (Rapid 2000, Taktik 3000)
    function buildStepDetails(baseline, current, stepsClaimed, maxRating) {
      const steps = [];

      for (let rating = 100; rating <= maxRating; rating += 100) {
        let status = "locked";
        let stepIndex = null;

        if (rating <= baseline) {
          status = "baseline";
        } else {
          stepIndex = Math.floor((rating - baseline) / 100);
          if (stepIndex <= 0) {
            status = current >= rating ? "open" : "locked";
          } else {
            if (current >= rating) {
              if (stepIndex <= stepsClaimed) {
                status = "paid";
              } else {
                status = "open";
              }
            } else {
              status = "locked";
            }
          }
        }

        steps.push({ rating, status });
      }

      return steps;
    }

    function computeRewardState(username, tacticsRating, rapidRating, rewardDoc) {
      const isChef = username === CHEF_USERNAME;
      const baselineT = rewardDoc.baselineTactics ?? 0;
      const baselineR = rewardDoc.baselineRapid   ?? 0;

      const tNow = tacticsRating ?? 0;
      const rNow = rapidRating   ?? 0;

      const deltaT = Math.max(0, tNow - baselineT);
      const tacticsStepsTotal = Math.floor(deltaT / 100);
      const tacticsRewardRaw  = tacticsStepsTotal * 10;

      const tacticsStepsClaimed = rewardDoc.tacticsStepsClaimed ?? 0;
      const tacticsStepsPaid    = Math.min(tacticsStepsClaimed, tacticsStepsTotal);
      const tacticsStepsNew     = Math.max(0, tacticsStepsTotal - tacticsStepsPaid);
      const tacticsPaid         = tacticsStepsPaid * 10;
      const tacticsUnpaid       = tacticsStepsNew  * 10;

      const nextTacticsTarget = baselineT + (tacticsStepsTotal + 1) * 100;
      const tacticsToNext     = Math.max(0, nextTacticsTarget - tNow);

      const deltaR = Math.max(0, rNow - baselineR);
      const rapidStepsTotal = Math.floor(deltaR / 100);
      const rapidStepsRewardRaw = rapidStepsTotal * 10;

      const rapidStepsClaimed = rewardDoc.rapidStepsClaimed ?? 0;
      const rapidStepsPaid    = Math.min(rapidStepsClaimed, rapidStepsTotal);
      const rapidStepsNew     = Math.max(0, rapidStepsTotal - rapidStepsPaid);
      const rapidStepsPaidEuro   = rapidStepsPaid * 10;
      const rapidStepsUnpaidEuro = rapidStepsNew * 10;

      // hier: verschiedene Obergrenzen
      const tacticsStepDetails = buildStepDetails(baselineT, tNow, tacticsStepsClaimed, TACTICS_MAX_STEP_RATING);
      const rapidStepDetails   = buildStepDetails(baselineR, rNow, rapidStepsClaimed, RAPID_MAX_STEP_RATING);

      const eloSteps = {
        tactics: {
          current: tNow,
          baseline: baselineT,
          total: tacticsStepsTotal,
          paid: tacticsStepsPaid,
          open: tacticsStepsNew,
          details: tacticsStepDetails
        },
        rapid: {
          current: rNow,
          baseline: baselineR,
          total: rapidStepsTotal,
          paid: rapidStepsPaid,
          open: rapidStepsNew,
          details: rapidStepDetails
        }
      };

      const claimedMilestones = rewardDoc.rapidMilestonesClaimed ?? [];

      const reachedMilestones = RAPID_MILESTONES.filter(m =>
        m.rating > baselineR && m.rating <= rNow
      );

      const milestoneDetails = RAPID_MILESTONES.map(m => {
        const reached = m.rating > baselineR && m.rating <= rNow;
        const paid = reached && claimedMilestones.includes(m.rating);
        return { rating: m.rating, reward: m.reward, reached, paid };
      });

      const newMilestones = reachedMilestones.filter(m => !claimedMilestones.includes(m.rating));
      const milestoneRewardRaw = reachedMilestones.reduce((sum, m) => sum + m.reward, 0);
      const milestonePaid = reachedMilestones
        .filter(m => claimedMilestones.includes(m.rating))
        .reduce((sum, m) => sum + m.reward, 0);
      const milestoneUnpaid = milestoneRewardRaw - milestonePaid;

      const rapidRewardRaw = rapidStepsRewardRaw + milestoneRewardRaw;
      const rapidPaid      = rapidStepsPaidEuro + milestonePaid;
      const rapidUnpaid    = rapidStepsUnpaidEuro + milestoneUnpaid;

      const totalRaw    = tacticsRewardRaw + rapidRewardRaw;
      const totalPaid   = tacticsPaid + rapidPaid;
      const totalUnpaid = totalRaw - totalPaid;

      const pending = rewardDoc.pendingClaim || null;

      const claimable = {
        tacticsStepsToClaim: tacticsStepsNew,
        rapidStepsToClaim: rapidStepsNew,
        rapidMilestonesToClaim: newMilestones.map(m => m.rating),
        amount: totalUnpaid
      };

      return {
        isChef,
        baselineT,
        baselineR,
        tactics: {
          now: tNow,
          rewardRaw: tacticsRewardRaw,
          paid: tacticsPaid,
          unpaid: tacticsUnpaid,
          toNext: tacticsToNext
        },
        rapid: {
          now: rNow,
          rewardRaw: rapidRewardRaw,
          paid: rapidPaid,
          unpaid: rapidUnpaid
        },
        total: {
          raw: totalRaw,
          paid: totalPaid,
          unpaid: totalUnpaid
        },
        rapidMilestones: {
          baseline: baselineR,
          details: milestoneDetails
        },
        eloSteps,
        claimable,
        pending
      };
    }

    async function createLifetimeClaim(username, rewardState) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);

      const { claimable } = rewardState;
      if (claimable.amount <= 0) return;

      const pendingClaim = {
        status: "requested",
        amount: claimable.amount,
        tacticsStepsToClaim: claimable.tacticsStepsToClaim,
        rapidStepsToClaim: claimable.rapidStepsToClaim,
        rapidMilestonesToClaim: claimable.rapidMilestonesToClaim,
        createdAt: serverTimestamp()
      };

      await updateDoc(ref, {
        pendingClaim,
        updatedAt: serverTimestamp()
      });
    }

    async function markLifetimeClaimPaid(username, rewardState) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      const pending = rewardState.pending;
      if (!pending || pending.status !== "requested") return;

      const snap = await getDoc(ref);
      if (!snap.exists()) return;
      const data = snap.data();

      const currentTacticsStepsClaimed = data.tacticsStepsClaimed ?? 0;
      const currentRapidStepsClaimed   = data.rapidStepsClaimed ?? 0;
      const currentRapidMilestonesClaimed = data.rapidMilestonesClaimed ?? [];

      const newTacticsStepsClaimed =
        currentTacticsStepsClaimed + (pending.tacticsStepsToClaim || 0);
      const newRapidStepsClaimed =
        currentRapidStepsClaimed + (pending.rapidStepsToClaim || 0);

      const newMilestonesClaimed = Array.from(
        new Set([
          ...currentRapidMilestonesClaimed,
          ...(pending.rapidMilestonesToClaim || [])
        ])
      );

      await updateDoc(ref, {
        tacticsStepsClaimed: newTacticsStepsClaimed,
        rapidStepsClaimed: newRapidStepsClaimed,
        rapidMilestonesClaimed: newMilestonesClaimed,
        pendingClaim: {
          ...pending,
          status: "paid",
          resolvedAt: serverTimestamp()
        },
        updatedAt: serverTimestamp()
      });
    }

    async function resetLifetimeClaim(username) {
      const id = username.toLowerCase();
      const ref = doc(db, REWARD_COLLECTION, id);
      await updateDoc(ref, {
        pendingClaim: null,
        updatedAt: serverTimestamp()
      });
    }

    function getCurrentWeekRange() {
      const now = new Date();
      const day = now.getDay();
      const diffToMonday = (day === 0 ? -6 : 1 - day);
      const monday = new Date(now);
      monday.setHours(0,0,0,0);
      monday.setDate(monday.getDate() + diffToMonday);

      const sunday = new Date(monday);
      sunday.setDate(sunday.getDate() + 6);
      sunday.setHours(23,59,59,999);

      const weekStartMs = monday.getTime();
      const weekEndMs = sunday.getTime();

      const year = monday.getFullYear();
      const weekNumber = getISOWeekNumber(monday);
      const weekKey = `${year}-W${String(weekNumber).padStart(2, "0")}`;

      return { weekStartMs, weekEndMs, weekKey };
    }

    function getISOWeekNumber(date) {
      const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = tmp.getUTCDay() || 7;
      tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 1));
      const weekNo = Math.ceil(((tmp - yearStart) / 86400000 + 1) / 7);
      return weekNo;
    }

    async function loadWeeklyStats(username) {
      const uname = username.toLowerCase();
      const { weekStartMs, weekEndMs } = getCurrentWeekRange();

      const startDate = new Date(weekStartMs);
      const endDate = new Date(weekEndMs);

      const months = getMonthsBetween(startDate, endDate);
      let totalGamesWeek = 0;
      let rapidGamesWeek = 0;
      let timeoutsWeek = 0;
      const activeDayIndexes = new Set();

      for (const { year, month } of months) {
        const monthStr = String(month).padStart(2, "0");
        try {
          const data = await fetchJson(`https://api.chess.com/pub/player/${uname}/games/${year}/${monthStr}`);
          const games = data.games || [];
          for (const g of games) {
            if (!g.end_time) continue;
            const endMs = g.end_time * 1000;
            if (endMs < weekStartMs || endMs > weekEndMs) continue;

            totalGamesWeek++;
            if (g.time_class === "rapid") rapidGamesWeek++;

            const whiteUser = g.white && g.white.username && g.white.username.toLowerCase();
            const blackUser = g.black && g.black.username && g.black.username.toLowerCase();

            let myResult = null;
            if (whiteUser === uname) myResult = g.white.result;
            else if (blackUser === uname) myResult = g.black.result;

            if (myResult === "timeout" || myResult === "abandoned") {
              timeoutsWeek++;
            }

            const dayIndex = Math.floor((endMs - weekStartMs) / (24 * 60 * 60 * 1000));
            if (dayIndex >= 0 && dayIndex < 7) activeDayIndexes.add(dayIndex);
          }
        } catch (e) {
          console.error("Fehler beim Laden des Monatsarchivs", year, monthStr, "f√ºr", username, e);
        }
      }

      const activeDaysCount = activeDayIndexes.size;

      return {
        totalGamesWeek,
        rapidGamesWeek,
        activeDaysCount,
        timeoutsWeek
      };
    }

    function getMonthsBetween(startDate, endDate) {
      const months = [];
      let year = startDate.getFullYear();
      let month = startDate.getMonth() + 1;

      while (year < endDate.getFullYear() || (year === endDate.getFullYear() && month <= endDate.getMonth() + 1)) {
        months.push({ year, month });
        month++;
        if (month > 12) {
          month = 1;
          year++;
        }
      }
      return months;
    }

    async function loadWeeklyDoc(username, weekKey) {
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      const snap = await getDoc(ref);

      if (!snap.exists()) {
        const initData = {
          username,
          weekKey,
          goalsPaid: [],
          totalPaid: 0,
          pendingClaim: null,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        };
        await setDoc(ref, initData);
        return initData;
      }

      return snap.data();
    }

    function computeWeeklyState(username, weeklyStats, weeklyDoc, weekKey) {
      const goalsPaid = weeklyDoc.goalsPaid || [];
      const totalPaid = weeklyDoc.totalPaid || 0;
      const pending = weeklyDoc.pendingClaim || null;

      const goalStates = WEEKLY_GOALS.map(goal => {
        let fulfilled = false;

        if (goal.id === "rapid10") {
          fulfilled = weeklyStats.rapidGamesWeek >= 10;
        } else if (goal.id === "games20") {
          fulfilled = weeklyStats.totalGamesWeek >= 20;
        } else if (goal.id === "days5") {
          fulfilled = weeklyStats.activeDaysCount >= 5;
        } else if (goal.id === "days7") {
          fulfilled = weeklyStats.activeDaysCount >= 7;
        } else if (goal.id === "noTimeouts") {
          fulfilled = weeklyStats.totalGamesWeek > 0 && weeklyStats.timeoutsWeek === 0;
        }

        const alreadyPaid = goalsPaid.includes(goal.id);

        return {
          id: goal.id,
          label: goal.label,
          amount: goal.amount,
          fulfilled,
          alreadyPaid
        };
      });

      const potentialGoals = goalStates.filter(g => g.fulfilled && !g.alreadyPaid);
      let remainingCap = Math.max(0, WEEKLY_CAP - totalPaid);
      let claimAmount = 0;
      const claimGoalIds = [];

      for (const g of potentialGoals) {
        if (g.amount <= remainingCap) {
          claimAmount += g.amount;
          claimGoalIds.push(g.id);
          remainingCap -= g.amount;
        }
      }

      const unpaid = claimAmount;
      const rawEarned = totalPaid + potentialGoals.reduce((s, g) => s + g.amount, 0);

      return {
        weekKey,
        weeklyStats,
        goalStates,
        totalPaid,
        unpaid,
        rawEarned,
        pending,
        claimPlan: {
          amount: claimAmount,
          goalIds: claimGoalIds
        }
      };
    }

    async function createWeeklyClaim(username, weeklyState) {
      const { claimPlan, weekKey } = weeklyState;
      if (claimPlan.amount <= 0) return;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);

      const pendingClaim = {
        status: "requested",
        amount: claimPlan.amount,
        goals: claimPlan.goalIds,
        createdAt: serverTimestamp()
      };

      await updateDoc(ref, {
        pendingClaim,
        updatedAt: serverTimestamp()
      });
    }

    async function markWeeklyClaimPaid(username, weeklyState) {
      const { weekKey } = weeklyState;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      const pending = weeklyState.pending;
      if (!pending || pending.status !== "requested") return;

      const snap = await getDoc(ref);
      if (!snap.exists()) return;
      const data = snap.data();

      const goalsPaid = data.goalsPaid || [];
      const totalPaid = data.totalPaid || 0;

      const newGoalsPaid = Array.from(new Set([...goalsPaid, ...(pending.goals || [])]));
      const newTotalPaid = totalPaid + (pending.amount || 0);

      await updateDoc(ref, {
        goalsPaid: newGoalsPaid,
        totalPaid: newTotalPaid,
        pendingClaim: {
          ...pending,
          status: "paid",
          resolvedAt: serverTimestamp()
        },
        updatedAt: serverTimestamp()
      });
    }

    async function resetWeeklyClaim(username, weeklyState) {
      const { weekKey } = weeklyState;
      const id = `${username.toLowerCase()}_${weekKey}`;
      const ref = doc(db, WEEKLY_COLLECTION, id);
      await updateDoc(ref, {
        pendingClaim: null,
        updatedAt: serverTimestamp()
      });
    }

    function buildAchievements(stats, rewardState) {
      const { totalGames, modes, tactics } = stats;
      const { total } = rewardState;
      const ach = [];

      if (totalGames >= 100) {
        ach.push({ label: "üèÉ Grinder", style: "silver" });
      } else if (totalGames >= 50) {
        ach.push({ label: "üéØ Warmgelaufen", style: "bronze" });
      }

      const modesWithGames = modes.filter(m => m.games >= 20 && m.winrate != null);
      if (modesWithGames.length) {
        modesWithGames.sort((a, b) => b.winrate - a.winrate);
        const best = modesWithGames[0];
        if (best.winrate >= 60) {
          ach.push({ label: `üî• ${best.label}`, style: "gold" });
        }
      }

      if (total.raw >= 50) {
        ach.push({ label: "üí∂ Rewards", style: "silver" });
      }

      if (tactics && tactics.current != null && tactics.current >= 2200) {
        ach.push({ label: "üß† Tactics", style: "gold" });
      }

      return ach.slice(0, 3);
    }

    function renderPlayerCard(stats, rewardState, weeklyState) {
      const cards = document.getElementById("cards");
      const card = document.createElement("article");
      card.className = "card";

      const isChef = rewardState.isChef;
      const isGf = stats.username === GIRLFRIEND_USERNAME;
      const isPayUser = stats.username === PAY_USER_USERNAME;

      if (isChef) card.classList.add("card-admin");
      else if (isPayUser) card.classList.add("card-pay");
      else if (isGf) card.classList.add("card-gf");

      const wrap = document.createElement("div");
      wrap.className = "card-inner";

      const header = document.createElement("div");
      header.className = "card-header";

      const left = document.createElement("div");
      left.className = "card-title-block";

      if (stats.avatar) {
        const img = document.createElement("img");
        img.src = stats.avatar;
        img.alt = stats.username;
        img.className = "avatar";
        left.appendChild(img);
      }

      const nameEl = document.createElement("div");
      nameEl.className = "username";
      nameEl.textContent = stats.username;
      left.appendChild(nameEl);

      header.appendChild(left);

      const status = document.createElement("div");
      status.className = "status-badge";

      if (isChef) {
        status.classList.add("status-admin");
        status.textContent = "ADMIN";
      } else if (isGf) {
        status.classList.add("status-gf");
        status.textContent = "GF";
      } else {
        status.classList.add(stats.active ? "status-active" : "status-chill");
        status.textContent = stats.active ? "AKTIV" : "PAUSE";
      }
      header.appendChild(status);

      wrap.appendChild(header);

      // Admin / M41K
      if (isChef) {
        const adminBox = document.createElement("div");
        adminBox.className = "admin-summary";

        const rapidMode = stats.modes.find(m => m.key === "chess_rapid");
        const blitzMode = stats.modes.find(m => m.key === "chess_blitz");
        const bulletMode = stats.modes.find(m => m.key === "chess_bullet");
        const dailyMode = stats.modes.find(m => m.key === "chess_daily");

        const tacticsRating = stats.tactics?.current ?? "‚Äì";
        const tacticsHighest = stats.tactics?.highest ?? "‚Äì";

        adminBox.innerHTML = `
          <div class="admin-row">
            <div class="admin-label">Rolle</div>
            <div class="admin-value">Bankroll & Orga</div>
          </div>
          <div class="admin-row">
            <div class="admin-label">Games gesamt</div>
            <div class="admin-value">${stats.totalGames}</div>
          </div>
          <div class="admin-row">
            <div class="admin-label">Rapid Elo</div>
            <div class="admin-value">${rapidMode?.current ?? "‚Äì"}</div>
          </div>
          <div class="admin-row">
            <div class="admin-label">Blitz / Bullet</div>
            <div class="admin-value">
              ${blitzMode?.current ?? "‚Äì"} / ${bulletMode?.current ?? "‚Äì"}
            </div>
          </div>
          <div class="admin-row">
            <div class="admin-label">Daily Elo</div>
            <div class="admin-value">${dailyMode?.current ?? "‚Äì"}</div>
          </div>
          <div class="admin-row">
            <div class="admin-label">Taktik Elo</div>
            <div class="admin-value">${tacticsRating} (max ${tacticsHighest})</div>
          </div>
        `;

        if (weeklyState && weeklyState.weeklyStats) {
          const { weeklyStats, weekKey } = weeklyState;
          const extra = document.createElement("div");
          extra.className = "admin-row";
          extra.innerHTML = `
            <div class="admin-label">Diese Woche</div>
            <div class="admin-value">
              ${weeklyStats.totalGamesWeek} G (${weeklyStats.rapidGamesWeek} Rapid)
            </div>
          `;
          adminBox.appendChild(extra);

          const extra2 = document.createElement("div");
          extra2.className = "admin-row admin-row-muted";
          extra2.innerHTML = `
            <div class="admin-label">${weekKey}</div>
            <div class="admin-value">${weeklyStats.activeDaysCount}/7 Tage ¬∑ TO: ${weeklyStats.timeoutsWeek}</div>
          `;
          adminBox.appendChild(extra2);
        }

        const foot = document.createElement("div");
        foot.className = "admin-footnote";
        foot.textContent = "Dieser Account nimmt nicht am Geldsystem teil ‚Äì reiner Coach / √úbersicht.";
        adminBox.appendChild(foot);

        wrap.appendChild(adminBox);

        const { eloSteps } = rewardState;
        if (eloSteps) {
          const stepsTitle = document.createElement("div");
          stepsTitle.className = "section-title";
          stepsTitle.textContent = "Elo Steps ‚Äì Own Grind";
          wrap.appendChild(stepsTitle);

          const stepsSubtitle = document.createElement("div");
          stepsSubtitle.className = "section-subtitle";
          stepsSubtitle.textContent = "100er Steps bis 2000 Rapid / 3000 Taktik ‚Äì nur Motivation, kein Geld.";
          wrap.appendChild(stepsSubtitle);

          const stepsBox = document.createElement("div");
          stepsBox.className = "admin-summary admin-steps";

          const stepContainer = document.createElement("div");
          stepContainer.className = "step-sections";

          const mapping = [
            { key: "rapid", label: "Rapid-Elo" },
            { key: "tactics", label: "Taktik-Elo" }
          ];

          mapping.forEach(cfg => {
            const group = eloSteps[cfg.key];
            if (!group) return;

            const section = document.createElement("div");
            section.className = "step-section";

            const headerSteps = document.createElement("div");
            headerSteps.className = "step-header";

            const leftLabel = document.createElement("div");
            leftLabel.className = "step-label";
            leftLabel.textContent = cfg.label;

            const rightInfo = document.createElement("div");
            rightInfo.innerHTML = `
              <span class="step-current">${group.current ?? "‚Äì"} Elo</span>
              <span class="step-summary">
                ¬∑ Steps erreicht: ${group.total}
              </span>
            `;

            headerSteps.appendChild(leftLabel);
            headerSteps.appendChild(rightInfo);
            section.appendChild(headerSteps);

            const grid = document.createElement("div");
            grid.className = "step-grid";

            group.details.forEach(step => {
              const item = document.createElement("div");
              let cls = "step-locked";
              if (step.status === "paid" || step.status === "open" || step.status === "baseline") {
                cls = "step-open";
              }
              item.className = `step-item ${cls}`;
              item.title = `${cfg.label}: ${step.rating} Elo`;
              item.innerHTML = `<span>${step.rating}</span>`;
              grid.appendChild(item);
            });

            section.appendChild(grid);
            stepContainer.appendChild(section);
          });

          stepsBox.appendChild(stepContainer);
          wrap.appendChild(stepsBox);
        }

        card.appendChild(wrap);
        cards.appendChild(card);
        return;
      }

      // Gemeinsamer Teil f√ºr ERR_Daemon + Kathi (Ratings + Badges)
      const modesTitle = document.createElement("div");
      modesTitle.className = "section-title";
      modesTitle.textContent = "Ratings & Games";
      wrap.appendChild(modesTitle);

      const modesWrap = document.createElement("div");
      modesWrap.className = "modes";

      if (!stats.modes.length) {
        const p = document.createElement("div");
        p.style.fontSize = "0.76rem";
        p.style.color = "#9ca3af";
        p.textContent = "Keine Partiedaten.";
        modesWrap.appendChild(p);
      } else {
        stats.modes.forEach(m => {
          const row = document.createElement("div");
          row.className = "mode-row";

          const leftCol = document.createElement("div");
          leftCol.className = "mode-left";

          const label = document.createElement("div");
          label.className = "mode-label";
          label.innerHTML = `${m.icon} ${m.label}`;
          leftCol.appendChild(label);

          const meta = document.createElement("div");
          meta.className = "mode-meta";
          const winrateText = m.winrate != null ? `${m.winrate}%` : "‚Äì";
          meta.textContent = `${m.games} G ¬∑ WR ${winrateText}`;
          leftCol.appendChild(meta);

          const rightCol = document.createElement("div");
          rightCol.className = "mode-right";

          const current = document.createElement("div");
          current.innerHTML = `<span class="rating">${m.current ?? "‚Äì"}</span>`;
          rightCol.appendChild(current);

          const gapText = document.createElement("div");
          if (m.best != null && m.current != null) {
            const gap = m.best - m.current;
            let cls = "gap-mid";
            let labelText = "";
            if (gap <= 0) {
              cls = "gap-good";
              labelText = "PB";
            } else if (gap <= 50) {
              cls = "gap-good";
              labelText = `-${gap}`;
            } else if (gap <= 100) {
              cls = "gap-mid";
              labelText = `-${gap}`;
            } else {
              cls = "gap-bad";
              labelText = `-${gap}`;
            }
            gapText.innerHTML = `<span class="${cls}">${labelText}</span>`;
          } else {
            gapText.textContent = "‚Äî";
          }
          rightCol.appendChild(gapText);

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          modesWrap.appendChild(row);
        });
      }

      wrap.appendChild(modesWrap);

      const achTitle = document.createElement("div");
      achTitle.className = "section-title";
      achTitle.textContent = "Badges";
      wrap.appendChild(achTitle);

      const achRow = document.createElement("div");
      achRow.className = "badge-row";
      const achievements = buildAchievements(stats, rewardState);

      if (!achievements.length) {
        const span = document.createElement("span");
        span.style.color = "#9ca3af";
        span.style.fontSize = "0.72rem";
        span.textContent = "Noch keine Badges.";
        achRow.appendChild(span);
      } else {
        achievements.forEach(a => {
          const span = document.createElement("span");
          span.className = `badge ${a.style}`;
          span.textContent = a.label;
          achRow.appendChild(span);
        });
      }
      wrap.appendChild(achRow);

      const isGfView = stats.username === GIRLFRIEND_USERNAME;

      // Freundin-View (Journey / Habits, kein Geld)
      if (isGfView) {
        const { eloSteps, rapidMilestones } = rewardState;

        const journeyTitle = document.createElement("div");
        journeyTitle.className = "section-title";
        journeyTitle.textContent = "Rating Journey";
        wrap.appendChild(journeyTitle);

        const journeyBox = document.createElement("div");
        journeyBox.className = "admin-summary";

        const rapidGroup = eloSteps?.rapid;
        const tacticsGroup = eloSteps?.tactics;

        if (rapidGroup) {
          const headerJ = document.createElement("div");
          headerJ.className = "gf-journey-header";
          headerJ.innerHTML = `
            <div class="gf-journey-label">‚è±Ô∏è Rapid ¬∑ <span>${rapidGroup.current ?? "‚Äì"} Elo</span></div>
            <div class="gf-tagline">Road to 2000</div>
          `;
          journeyBox.appendChild(headerJ);

          const grid = document.createElement("div");
          grid.className = "step-grid";

          rapidGroup.details.forEach(step => {
            const item = document.createElement("div");
            let cls = "step-locked";
            if (step.status === "paid" || step.status === "open" || step.status === "baseline") {
              cls = "step-open";
            }
            item.className = `step-item ${cls}`;
            item.innerHTML = `<span>${step.rating}</span>`;
            grid.appendChild(item);
          });

          journeyBox.appendChild(grid);
        }

        if (tacticsGroup) {
          const headerT = document.createElement("div");
          headerT.className = "gf-journey-header";
          headerT.innerHTML = `
            <div class="gf-journey-label">üß† Taktik ¬∑ <span>${tacticsGroup.current ?? "‚Äì"} Elo</span></div>
            <div class="gf-tagline">Brain Gains</div>
          `;
          journeyBox.appendChild(headerT);

          const gridT = document.createElement("div");
          gridT.className = "step-grid";

          tacticsGroup.details.forEach(step => {
            const item = document.createElement("div");
            let cls = "step-locked";
            if (step.status === "paid" || step.status === "open" || step.status === "baseline") {
              cls = "step-open";
            }
            item.className = `step-item ${cls}`;
            item.innerHTML = `<span>${step.rating}</span>`;
            gridT.appendChild(item);
          });

          journeyBox.appendChild(gridT);
        }

        if (rapidMilestones && rapidMilestones.details) {
          const dotsWrapper = document.createElement("div");
          dotsWrapper.className = "gf-dot-row";

          rapidMilestones.details.forEach(ms => {
            const dot = document.createElement("div");
            dot.className = "gf-dot";
            if (ms.paid || ms.reached) dot.classList.add("gf-dot-reached");
            dot.title = `Rapid ${ms.rating}`;
            dotsWrapper.appendChild(dot);
          });

          journeyBox.appendChild(dotsWrapper);

          const note = document.createElement("div");
          note.className = "gf-note";
          note.textContent = "Gef√ºllte Punkte = Meilensteine, die du schon angestupst hast.";
          journeyBox.appendChild(note);
        }

        wrap.appendChild(journeyBox);

        if (weeklyState) {
          const habitsTitle = document.createElement("div");
          habitsTitle.className = "section-title";
          habitsTitle.textContent = "Weekly Habits";
          wrap.appendChild(habitsTitle);

          const habitsBox = document.createElement("div");
          habitsBox.className = "admin-summary";

          const { weeklyStats, goalStates, weekKey } = weeklyState;

          habitsBox.innerHTML = `
            <div style="font-size:0.74rem;margin-bottom:0.2rem;">
              ${weekKey} ¬∑ ${weeklyStats.totalGamesWeek} Games (${weeklyStats.rapidGamesWeek} Rapid) ¬∑ ${weeklyStats.activeDaysCount}/7 Tage
            </div>
          `;

          const goalsDiv = document.createElement("div");
          goalsDiv.className = "weekly-goals";

          goalStates.forEach(g => {
            const row = document.createElement("div");
            row.className = "weekly-goal-row";

            const leftCol = document.createElement("div");
            leftCol.className = "weekly-goal-name";
            leftCol.textContent = g.label;

            const rightCol = document.createElement("div");
            rightCol.className = "weekly-goal-status";

            if (g.fulfilled) {
              rightCol.innerHTML = `<span class="status-ok">‚úî</span>`;
            } else {
              rightCol.innerHTML = `<span class="status-missing">‚Ä¶</span>`;
            }

            row.appendChild(leftCol);
            row.appendChild(rightCol);
            goalsDiv.appendChild(row);
          });

          habitsBox.appendChild(goalsDiv);

          wrap.appendChild(habitsBox);
        }

        card.appendChild(wrap);
        cards.appendChild(card);
        return;
      }

      // ERR_Daemon ‚Äì Geld-/Claim-√úbersicht
      const rewardTitle = document.createElement("div");
      rewardTitle.className = "section-title";
      rewardTitle.textContent = "Lifetime Rewards";
      wrap.appendChild(rewardTitle);

      const rewardSubtitle = document.createElement("div");
      rewardSubtitle.className = "section-subtitle";
      rewardSubtitle.textContent = "Elo-Steps & Rapid-Meilensteine (bis 2000 Rapid / 3000 Taktik)";
      wrap.appendChild(rewardSubtitle);

      const rewardBox = document.createElement("div");
      rewardBox.className = "admin-summary";

      const { total, rapidMilestones, eloSteps, pending } = rewardState;
      const activePending = pending && pending.status === "requested" ? pending : null;

      if (eloSteps) {
        const stepContainer = document.createElement("div");
        stepContainer.className = "step-sections";

        const mapping = [
          { key: "rapid", label: "Rapid-Elo Steps" },
          { key: "tactics", label: "Taktik-Elo Steps" }
        ];

        mapping.forEach(cfg => {
          const group = eloSteps[cfg.key];
          if (!group) return;

          const section = document.createElement("div");
          section.className = "step-section";

          const headerSteps = document.createElement("div");
          headerSteps.className = "step-header";

          const leftLabel = document.createElement("div");
          leftLabel.className = "step-label";
          leftLabel.textContent = cfg.label;

          const rightInfo = document.createElement("div");
          rightInfo.innerHTML = `
            <span class="step-current">${group.current ?? "‚Äì"} Elo</span>
            <span class="step-summary">
              ¬∑ Steps bezahlt: ${group.paid} ¬∑ offen: ${group.open}
            </span>
          `;

          headerSteps.appendChild(leftLabel);
          headerSteps.appendChild(rightInfo);
          section.appendChild(headerSteps);

          const grid = document.createElement("div");
          grid.className = "step-grid";

          group.details.forEach(step => {
            const item = document.createElement("div");
            let cls = "step-locked";
            if (step.status === "paid") cls = "step-paid";
            else if (step.status === "open") cls = "step-open";
            else if (step.status === "baseline") cls = "step-baseline";

            item.className = `step-item ${cls}`;
            item.title = `${cfg.label}: ${step.rating} Elo`;
            item.innerHTML = `<span>${step.rating}</span>`;
            grid.appendChild(item);
          });

          section.appendChild(grid);
          stepContainer.appendChild(section);
        });

        rewardBox.appendChild(stepContainer);
      }

      if (rapidMilestones && rapidMilestones.details && rapidMilestones.details.length) {
        const msList = document.createElement("div");
        msList.className = "weekly-goals";

        rapidMilestones.details.forEach(ms => {
          const row = document.createElement("div");
          row.className = "weekly-goal-row";

          const leftCol = document.createElement("div");
          leftCol.className = "weekly-goal-name";
          leftCol.textContent = `Rapid ${ms.rating} (${ms.reward} ‚Ç¨)`;

          const rightCol = document.createElement("div");
          rightCol.className = "weekly-goal-status";

          if (ms.paid) {
            rightCol.innerHTML = `<span class="status-paid">bezahlt</span>`;
          } else if (ms.reached) {
            rightCol.innerHTML = `<span class="status-ok">erreicht</span>`;
          } else {
            rightCol.innerHTML = `<span class="status-missing">offen</span>`;
          }

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          msList.appendChild(row);
        });

        rewardBox.appendChild(msList);
      }

      const chip = document.createElement("div");
      let chipClass, chipText;
      if (activePending) {
        chipClass = "chip-requested";
        chipText = `Claim offen: ${activePending.amount} ‚Ç¨`;
      } else if (total.unpaid > 0) {
        chipClass = "chip-open";
        chipText = `Offener Betrag: ${total.unpaid} ‚Ç¨ ¬∑ schon gezahlt: ${total.paid} ‚Ç¨`;
      } else {
        chipClass = "chip-paid";
        chipText = `Alles ausgezahlt ¬∑ Gesamt: ${total.raw} ‚Ç¨`;
      }
      chip.className = `reward-chip ${chipClass}`;
      chip.textContent = chipText;
      rewardBox.appendChild(chip);

      if (!activePending && total.unpaid > 0) {
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.textContent = `Claim (${total.unpaid} ‚Ç¨)`;
        btn.addEventListener("click", async () => {
          btn.disabled = true;
          await createLifetimeClaim(stats.username, rewardState);
          location.reload();
        });
        rewardBox.appendChild(btn);
      } else if (activePending) {
        const btnPaid = document.createElement("button");
        btnPaid.className = "btn";
        btnPaid.textContent = `Ausgezahlt (${activePending.amount} ‚Ç¨)`;
        btnPaid.addEventListener("click", async () => {
          btnPaid.disabled = true;
          await markLifetimeClaimPaid(stats.username, rewardState);
          location.reload();
        });
        rewardBox.appendChild(btnPaid);

        const btnCancel = document.createElement("button");
        btnCancel.className = "btn btn-danger";
        btnCancel.textContent = "Reset";
        btnCancel.addEventListener("click", async () => {
          btnCancel.disabled = true;
          await resetLifetimeClaim(stats.username);
          location.reload();
        });
        rewardBox.appendChild(btnCancel);
      }

      wrap.appendChild(rewardBox);

      if (weeklyState) {
        const weeklyTitle = document.createElement("div");
        weeklyTitle.className = "section-title";
        weeklyTitle.textContent = "Weekly Bonus";
        wrap.appendChild(weeklyTitle);

        const weeklyBox = document.createElement("div");
        weeklyBox.className = "admin-summary";

        const { weeklyStats, goalStates, unpaid, totalPaid, pending, claimPlan, weekKey } = weeklyState;
        const activePendingW = pending && pending.status === "requested" ? pending : null;

        weeklyBox.innerHTML = `
          <div style="font-size:0.74rem;margin-bottom:0.2rem;">
            ${weekKey} ¬∑ ${weeklyStats.totalGamesWeek} G (${weeklyStats.rapidGamesWeek} Rapid) ¬∑ ${weeklyStats.activeDaysCount}/7 Tage ¬∑ TO: ${weeklyStats.timeoutsWeek}
          </div>
          <div class="admin-row">
            <div class="admin-label">Paid Woche</div>
            <div class="admin-value">${totalPaid} ‚Ç¨</div>
          </div>
          <div class="admin-row">
            <div class="admin-label">Potenzial offen</div>
            <div class="admin-value">${unpaid} ‚Ç¨</div>
          </div>
        `;

        const goalsDiv = document.createElement("div");
        goalsDiv.className = "weekly-goals";

        goalStates.forEach(g => {
          const row = document.createElement("div");
          row.className = "weekly-goal-row";

          const leftCol = document.createElement("div");
          leftCol.className = "weekly-goal-name";
          leftCol.textContent = `${g.label} (${g.amount} ‚Ç¨)`;

          const rightCol = document.createElement("div");
          rightCol.className = "weekly-goal-status";

          if (g.alreadyPaid) {
            rightCol.innerHTML = `<span class="status-paid">bezahlt</span>`;
          } else if (g.fulfilled) {
            rightCol.innerHTML = `<span class="status-ok">erreicht</span>`;
          } else {
            rightCol.innerHTML = `<span class="status-missing">offen</span>`;
          }

          row.appendChild(leftCol);
          row.appendChild(rightCol);
          goalsDiv.appendChild(row);
        });

        weeklyBox.appendChild(goalsDiv);

        const chipW = document.createElement("div");
        let chipClassW, chipTextW;
        if (activePendingW) {
          chipClassW = "chip-requested";
          chipTextW = `Weekly-Claim: ${activePendingW.amount} ‚Ç¨`;
        } else if (unpaid > 0) {
          chipClassW = "chip-open";
          chipTextW = `Offen: ${unpaid} ‚Ç¨`;
        } else {
          chipClassW = "chip-paid";
          chipTextW = "Weekly voll.";
        }
        chipW.className = `reward-chip ${chipClassW}`;
        chipW.textContent = chipTextW;
        weeklyBox.appendChild(chipW);

        if (!activePendingW && claimPlan.amount > 0) {
          const btn = document.createElement("button");
          btn.className = "btn";
          btn.textContent = `Claim (${claimPlan.amount} ‚Ç¨)`;
          btn.addEventListener("click", async () => {
            btn.disabled = true;
            await createWeeklyClaim(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btn);
        } else if (activePendingW) {
          const btnPaid = document.createElement("button");
          btnPaid.className = "btn";
          btnPaid.textContent = `Ausgezahlt (${activePendingW.amount} ‚Ç¨)`;
          btnPaid.addEventListener("click", async () => {
            btnPaid.disabled = true;
            await markWeeklyClaimPaid(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btnPaid);

          const btnCancel = document.createElement("button");
          btnCancel.className = "btn btn-danger";
          btnCancel.textContent = "Reset";
          btnCancel.addEventListener("click", async () => {
            btnCancel.disabled = true;
            await resetWeeklyClaim(stats.username, weeklyState);
            location.reload();
          });
          weeklyBox.appendChild(btnCancel);
        }

        wrap.appendChild(weeklyBox);
      }

      card.appendChild(wrap);
      cards.appendChild(card);
    }

    async function init() {
      const subtitle = document.getElementById("subtitle");
      try {
        subtitle.textContent = "Lade Chess.com & Firestore‚Ä¶";
        const { weekKey } = getCurrentWeekRange();
        const playersCombined = [];

        for (const name of PLAYERS) {
          try {
            const stats = await loadChessStats(name);
            const [rewardDoc, weeklyStats, weeklyDoc] = await Promise.all([
              loadRewardDoc(name, stats.tacticsRating, stats.rapidRating),
              loadWeeklyStats(name),
              loadWeeklyDoc(name, weekKey)
            ]);

            const rewardState = computeRewardState(name, stats.tacticsRating, stats.rapidRating, rewardDoc);
            const weeklyState = computeWeeklyState(name, weeklyStats, weeklyDoc, weekKey);

            playersCombined.push({ stats, rewardState, weeklyState });
          } catch (e) {
            console.error("Fehler bei Spieler", name, e);
          }
        }

        playersCombined
          .sort((a, b) => {
            const order = (player) => {
              if (player.stats.username === PAY_USER_USERNAME) return 0;
              if (player.stats.username === GIRLFRIEND_USERNAME) return 1;
              if (player.stats.username === CHEF_USERNAME) return 2;
              return 3;
            };
            return order(a) - order(b);
          })
          .forEach(p => renderPlayerCard(p.stats, p.rewardState, p.weeklyState));

        const now = new Date();
        subtitle.textContent = `Stand: ${now.toLocaleString()}`;
      } catch (e) {
        console.error(e);
        subtitle.textContent = "Fehler beim Laden (siehe Konsole)";
      }
    }

    init();
  </script>
</body>
</html>
